"""
This type stub file was generated by pyright.
"""

from sqlalchemy import types as sqltypes
from sqlalchemy.engine import default, reflection
from sqlalchemy.sql import compiler
from sqlalchemy.types import BIGINT, BINARY, CHAR, DATE, DATETIME, DECIMAL, FLOAT, INTEGER, NCHAR, NUMERIC, NVARCHAR, REAL, SMALLINT, TEXT, TIME, TIMESTAMP, Unicode, VARBINARY, VARCHAR

"""

.. dialect:: sybase
    :name: Sybase

.. note::

    The Sybase dialect within SQLAlchemy **is not currently supported**.
    It is not tested within continuous integration and is likely to have
    many issues and caveats not currently handled. Consider using the
    `external dialect <https://github.com/gordthompson/sqlalchemy-sybase>`_
    instead.

"""
RESERVED_WORDS = set(["add", "all", "alter", "and", "any", "as", "asc", "backup", "begin", "between", "bigint", "binary", "bit", "bottom", "break", "by", "call", "capability", "cascade", "case", "cast", "char", "char_convert", "character", "check", "checkpoint", "close", "comment", "commit", "connect", "constraint", "contains", "continue", "convert", "create", "cross", "cube", "current", "current_timestamp", "current_user", "cursor", "date", "dbspace", "deallocate", "dec", "decimal", "declare", "default", "delete", "deleting", "desc", "distinct", "do", "double", "drop", "dynamic", "else", "elseif", "encrypted", "end", "endif", "escape", "except", "exception", "exec", "execute", "existing", "exists", "externlogin", "fetch", "first", "float", "for", "force", "foreign", "forward", "from", "full", "goto", "grant", "group", "having", "holdlock", "identified", "if", "in", "index", "index_lparen", "inner", "inout", "insensitive", "insert", "inserting", "install", "instead", "int", "integer", "integrated", "intersect", "into", "iq", "is", "isolation", "join", "key", "lateral", "left", "like", "lock", "login", "long", "match", "membership", "message", "mode", "modify", "natural", "new", "no", "noholdlock", "not", "notify", "null", "numeric", "of", "off", "on", "open", "option", "options", "or", "order", "others", "out", "outer", "over", "passthrough", "precision", "prepare", "primary", "print", "privileges", "proc", "procedure", "publication", "raiserror", "readtext", "real", "reference", "references", "release", "remote", "remove", "rename", "reorganize", "resource", "restore", "restrict", "return", "revoke", "right", "rollback", "rollup", "save", "savepoint", "scroll", "select", "sensitive", "session", "set", "setuser", "share", "smallint", "some", "sqlcode", "sqlstate", "start", "stop", "subtrans", "subtransaction", "synchronize", "syntax_error", "table", "temporary", "then", "time", "timestamp", "tinyint", "to", "top", "tran", "trigger", "truncate", "tsequal", "unbounded", "union", "unique", "unknown", "unsigned", "update", "updating", "user", "using", "validate", "values", "varbinary", "varchar", "variable", "varying", "view", "wait", "waitfor", "when", "where", "while", "window", "with", "with_cube", "with_lparen", "with_rollup", "within", "work", "writetext"])
class _SybaseUnitypeMixin(object):
    """these types appear to return a buffer object."""
    def result_processor(self, dialect, coltype):
        ...
    


class UNICHAR(_SybaseUnitypeMixin, sqltypes.Unicode):
    __visit_name__ = ...


class UNIVARCHAR(_SybaseUnitypeMixin, sqltypes.Unicode):
    __visit_name__ = ...


class UNITEXT(_SybaseUnitypeMixin, sqltypes.UnicodeText):
    __visit_name__ = ...


class TINYINT(sqltypes.Integer):
    __visit_name__ = ...


class BIT(sqltypes.TypeEngine):
    __visit_name__ = ...


class MONEY(sqltypes.TypeEngine):
    __visit_name__ = ...


class SMALLMONEY(sqltypes.TypeEngine):
    __visit_name__ = ...


class UNIQUEIDENTIFIER(sqltypes.TypeEngine):
    __visit_name__ = ...


class IMAGE(sqltypes.LargeBinary):
    __visit_name__ = ...


class SybaseTypeCompiler(compiler.GenericTypeCompiler):
    def visit_large_binary(self, type_, **kw):
        ...
    
    def visit_boolean(self, type_, **kw):
        ...
    
    def visit_unicode(self, type_, **kw):
        ...
    
    def visit_UNICHAR(self, type_, **kw):
        ...
    
    def visit_UNIVARCHAR(self, type_, **kw):
        ...
    
    def visit_UNITEXT(self, type_, **kw):
        ...
    
    def visit_TINYINT(self, type_, **kw):
        ...
    
    def visit_IMAGE(self, type_, **kw):
        ...
    
    def visit_BIT(self, type_, **kw):
        ...
    
    def visit_MONEY(self, type_, **kw):
        ...
    
    def visit_SMALLMONEY(self, type_, **kw):
        ...
    
    def visit_UNIQUEIDENTIFIER(self, type_, **kw):
        ...
    


ischema_names = { "bigint": BIGINT,"int": INTEGER,"integer": INTEGER,"smallint": SMALLINT,"tinyint": TINYINT,"unsigned bigint": BIGINT,"unsigned int": INTEGER,"unsigned smallint": SMALLINT,"numeric": NUMERIC,"decimal": DECIMAL,"dec": DECIMAL,"float": FLOAT,"double": NUMERIC,"double precision": NUMERIC,"real": REAL,"smallmoney": SMALLMONEY,"money": MONEY,"smalldatetime": DATETIME,"datetime": DATETIME,"date": DATE,"time": TIME,"char": CHAR,"character": CHAR,"varchar": VARCHAR,"character varying": VARCHAR,"char varying": VARCHAR,"unichar": UNICHAR,"unicode character": UNIVARCHAR,"nchar": NCHAR,"national char": NCHAR,"national character": NCHAR,"nvarchar": NVARCHAR,"nchar varying": NVARCHAR,"national char varying": NVARCHAR,"national character varying": NVARCHAR,"text": TEXT,"unitext": UNITEXT,"binary": BINARY,"varbinary": VARBINARY,"image": IMAGE,"bit": BIT,"long varchar": TEXT,"timestamp": TIMESTAMP,"uniqueidentifier": UNIQUEIDENTIFIER }
class SybaseInspector(reflection.Inspector):
    def __init__(self, conn) -> None:
        ...
    
    def get_table_id(self, table_name, schema=...):
        """Return the table id from `table_name` and `schema`."""
        ...
    


class SybaseExecutionContext(default.DefaultExecutionContext):
    _enable_identity_insert = ...
    def set_ddl_autocommit(self, connection, value):
        """Must be implemented by subclasses to accommodate DDL executions.

        "connection" is the raw unwrapped DBAPI connection.   "value"
        is True or False.  when True, the connection should be configured
        such that a DDL can take place subsequently.  when False,
        a DDL has taken place and the connection should be resumed
        into non-autocommit mode.

        """
        ...
    
    def pre_exec(self):
        ...
    
    def post_exec(self):
        ...
    
    def get_lastrowid(self):
        ...
    


class SybaseSQLCompiler(compiler.SQLCompiler):
    ansi_bind_rules = ...
    extract_map = ...
    def get_from_hint_text(self, table, text):
        ...
    
    def limit_clause(self, select, **kw):
        ...
    
    def visit_extract(self, extract, **kw):
        ...
    
    def visit_now_func(self, fn, **kw):
        ...
    
    def for_update_clause(self, select):
        ...
    
    def order_by_clause(self, select, **kw):
        ...
    
    def delete_table_clause(self, delete_stmt, from_table, extra_froms):
        """If we have extra froms make sure we render any alias as hint."""
        ...
    
    def delete_extra_from_clause(self, delete_stmt, from_table, extra_froms, from_hints, **kw):
        """Render the DELETE .. FROM clause specific to Sybase."""
        ...
    


class SybaseDDLCompiler(compiler.DDLCompiler):
    def get_column_specification(self, column, **kwargs):
        ...
    
    def visit_drop_index(self, drop):
        ...
    


class SybaseIdentifierPreparer(compiler.IdentifierPreparer):
    reserved_words = ...


class SybaseDialect(default.DefaultDialect):
    name = ...
    supports_unicode_statements = ...
    supports_sane_rowcount = ...
    supports_sane_multi_rowcount = ...
    supports_native_boolean = ...
    supports_unicode_binds = ...
    postfetch_lastrowid = ...
    colspecs = ...
    ischema_names = ...
    type_compiler = ...
    statement_compiler = ...
    ddl_compiler = ...
    preparer = ...
    inspector = ...
    construct_arguments = ...
    def initialize(self, connection):
        ...
    
    def get_table_id(self, connection, table_name, schema=..., **kw):
        """Fetch the id for schema.table_name.

        Several reflection methods require the table id.  The idea for using
        this method is that it can be fetched one time and cached for
        subsequent calls.

        """
        ...
    
    @reflection.cache
    def get_columns(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_foreign_keys(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_indexes(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_pk_constraint(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_schema_names(self, connection, **kw):
        ...
    
    @reflection.cache
    def get_table_names(self, connection, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_view_definition(self, connection, view_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_view_names(self, connection, schema=..., **kw):
        ...
    
    def has_table(self, connection, table_name, schema=...):
        ...
    


