"""
This type stub file was generated by pyright.
"""

from ... import sql, types as sqltypes
from ...engine import default, reflection
from ...sql import compiler
from ...types import BLOB, CHAR, CLOB, FLOAT, NCHAR, NVARCHAR, TIMESTAMP, VARCHAR

r"""
.. dialect:: oracle
    :name: Oracle

    Oracle version 8 through current (11g at the time of this writing) are
    supported.


Auto Increment Behavior
-----------------------

SQLAlchemy Table objects which include integer primary keys are usually
assumed to have "autoincrementing" behavior, meaning they can generate their
own primary key values upon INSERT.  Since Oracle has no "autoincrement"
feature, SQLAlchemy relies upon sequences to produce these values.   With the
Oracle dialect, *a sequence must always be explicitly specified to enable
autoincrement*.  This is divergent with the majority of documentation
examples which assume the usage of an autoincrement-capable database.   To
specify sequences, use the sqlalchemy.schema.Sequence object which is passed
to a Column construct::

  t = Table('mytable', metadata,
        Column('id', Integer, Sequence('id_seq'), primary_key=True),
        Column(...), ...
  )

This step is also required when using table reflection, i.e. autoload=True::

  t = Table('mytable', metadata,
        Column('id', Integer, Sequence('id_seq'), primary_key=True),
        autoload=True
  )

Transaction Isolation Level / Autocommit
----------------------------------------

The Oracle database supports "READ COMMITTED" and "SERIALIZABLE" modes
of isolation, however the SQLAlchemy Oracle dialect currently only has
explicit support for "READ COMMITTED".  It is possible to emit a
"SET TRANSACTION" statement on a connection in order to use SERIALIZABLE
isolation, however the SQLAlchemy dialect will remain unaware of this setting,
such as if the :meth:`_engine.Connection.get_isolation_level` method is used;
this method is hardcoded to return "READ COMMITTED" right now.

The AUTOCOMMIT isolation level is also supported by the cx_Oracle dialect.

To set using per-connection execution options::

    connection = engine.connect()
    connection = connection.execution_options(
        isolation_level="AUTOCOMMIT"
    )

Valid values for ``isolation_level`` include:

* ``READ COMMITTED``
* ``AUTOCOMMIT``


.. versionadded:: 1.3.16 added support for AUTOCOMMIT to the cx_oracle dialect
   as well as the notion of a default isolation level, currently hardcoded
   to "READ COMMITTED".

.. seealso::

    :ref:`dbapi_autocommit`

Identifier Casing
-----------------

In Oracle, the data dictionary represents all case insensitive identifier
names using UPPERCASE text.   SQLAlchemy on the other hand considers an
all-lower case identifier name to be case insensitive.   The Oracle dialect
converts all case insensitive identifiers to and from those two formats during
schema level communication, such as reflection of tables and indexes.   Using
an UPPERCASE name on the SQLAlchemy side indicates a case sensitive
identifier, and SQLAlchemy will quote the name - this will cause mismatches
against data dictionary data received from Oracle, so unless identifier names
have been truly created as case sensitive (i.e. using quoted names), all
lowercase names should be used on the SQLAlchemy side.

.. _oracle_max_identifier_lengths:

Max Identifier Lengths
----------------------

Oracle has changed the default max identifier length as of Oracle Server
version 12.2.   Prior to this version, the length was 30, and for 12.2 and
greater it is now 128.   This change impacts SQLAlchemy in the area of
generated SQL label names as well as the generation of constraint names,
particularly in the case where the constraint naming convention feature
described at :ref:`constraint_naming_conventions` is being used.

To assist with this change and others, Oracle includes the concept of a
"compatibility" version, which is a version number that is independent of the
actual server version in order to assist with migration of Oracle databases,
and may be configured within the Oracle server itself. This compatibility
version is retrieved using the query  ``SELECT value FROM v$parameter WHERE
name = 'compatible';``.   The SQLAlchemy Oracle dialect, when tasked with
determining the default max identifier length, will attempt to use this query
upon first connect in order to determine the effective compatibility version of
the server, which determines what the maximum allowed identifier length is for
the server.  If the table is not available, the  server version information is
used instead.

For the duration of the SQLAlchemy 1.3 series, the default max identifier
length will remain at 30, even if compatibility version 12.2 or greater is in
use.  When the newer version is detected, a warning will be emitted upon first
connect, which refers the user to make use of the
:paramref:`_sa.create_engine.max_identifier_length`
parameter in order to assure
forwards compatibility with SQLAlchemy 1.4, which will be changing this value
to 128 when compatibility version 12.2 or greater is detected.

Using :paramref:`_sa.create_engine.max_identifier_length`,
the effective identifier
length used by the SQLAlchemy dialect will be used as given, overriding the
current default value of 30, so that when Oracle 12.2 or greater is used, the
newer identifier length may be taken advantage of::

    engine = create_engine(
        "oracle+cx_oracle://scott:tiger@oracle122",
        max_identifier_length=128)

The maximum identifier length comes into play both when generating anonymized
SQL labels in SELECT statements, but more crucially when generating constraint
names from a naming convention.  It is this area that has created the need for
SQLAlchemy to change this default conservatively.   For example, the following
naming convention produces two very different constraint names based on the
identifier length::

    from sqlalchemy import Column
    from sqlalchemy import Index
    from sqlalchemy import Integer
    from sqlalchemy import MetaData
    from sqlalchemy import Table
    from sqlalchemy.dialects import oracle
    from sqlalchemy.schema import CreateIndex

    m = MetaData(naming_convention={"ix": "ix_%(column_0N_name)s"})

    t = Table(
        "t",
        m,
        Column("some_column_name_1", Integer),
        Column("some_column_name_2", Integer),
        Column("some_column_name_3", Integer),
    )

    ix = Index(
        None,
        t.c.some_column_name_1,
        t.c.some_column_name_2,
        t.c.some_column_name_3,
    )

    oracle_dialect = oracle.dialect(max_identifier_length=30)
    print(CreateIndex(ix).compile(dialect=oracle_dialect))

With an identifier length of 30, the above CREATE INDEX looks like::

    CREATE INDEX ix_some_column_name_1s_70cd ON t
    (some_column_name_1, some_column_name_2, some_column_name_3)

However with length=128, it becomes::

    CREATE INDEX ix_some_column_name_1some_column_name_2some_column_name_3 ON t
    (some_column_name_1, some_column_name_2, some_column_name_3)

The implication here is that by upgrading SQLAlchemy to version 1.4 on
an existing Oracle 12.2 or greater database, the generation of constraint
names will change, which can impact the behavior of database migrations.
A key example is a migration that wishes to "DROP CONSTRAINT" on a name that
was previously generated with the shorter length.  This migration will fail
when the identifier length is changed without the name of the index or
constraint first being adjusted.

Therefore, applications are strongly advised to make use of
:paramref:`_sa.create_engine.max_identifier_length`
in order to maintain control
of the generation of truncated names, and to fully review and test all database
migrations in a staging environment when changing this value to ensure that the
impact of this change has been mitigated.


.. versionadded:: 1.3.9 Added the
   :paramref:`_sa.create_engine.max_identifier_length` parameter; the Oracle
   dialect now detects compatibility version 12.2 or greater and warns
   about upcoming max identitifier length changes in SQLAlchemy 1.4.


LIMIT/OFFSET Support
--------------------

Oracle has no support for the LIMIT or OFFSET keywords.  SQLAlchemy uses
a wrapped subquery approach in conjunction with ROWNUM.  The exact methodology
is taken from
http://www.oracle.com/technetwork/issue-archive/2006/06-sep/o56asktom-086197.html .

There are two options which affect its behavior:

* the "FIRST ROWS()" optimization keyword is not used by default.  To enable
  the usage of this optimization directive, specify ``optimize_limits=True``
  to :func:`_sa.create_engine`.
* the values passed for the limit/offset are sent as bound parameters.   Some
  users have observed that Oracle produces a poor query plan when the values
  are sent as binds and not rendered literally.   To render the limit/offset
  values literally within the SQL statement, specify
  ``use_binds_for_limits=False`` to :func:`_sa.create_engine`.

Some users have reported better performance when the entirely different
approach of a window query is used, i.e. ROW_NUMBER() OVER (ORDER BY), to
provide LIMIT/OFFSET (note that the majority of users don't observe this).
To suit this case the method used for LIMIT/OFFSET can be replaced entirely.
See the recipe at
http://www.sqlalchemy.org/trac/wiki/UsageRecipes/WindowFunctionsByDefault
which installs a select compiler that overrides the generation of limit/offset
with a window function.

.. _oracle_returning:

RETURNING Support
-----------------

The Oracle database supports a limited form of RETURNING, in order to retrieve
result sets of matched rows from INSERT, UPDATE and DELETE statements.
Oracle's RETURNING..INTO syntax only supports one row being returned, as it
relies upon OUT parameters in order to function.  In addition, supported
DBAPIs have further limitations (see :ref:`cx_oracle_returning`).

SQLAlchemy's "implicit returning" feature, which employs RETURNING within an
INSERT and sometimes an UPDATE statement in order to fetch newly generated
primary key values and other SQL defaults and expressions, is normally enabled
on the Oracle backend.  By default, "implicit returning" typically only
fetches the value of a single ``nextval(some_seq)`` expression embedded into
an INSERT in order to increment a sequence within an INSERT statement and get
the value back at the same time. To disable this feature across the board,
specify ``implicit_returning=False`` to :func:`_sa.create_engine`::

    engine = create_engine("oracle://scott:tiger@dsn",
                           implicit_returning=False)

Implicit returning can also be disabled on a table-by-table basis as a table
option::

    # Core Table
    my_table = Table("my_table", metadata, ..., implicit_returning=False)


    # declarative
    class MyClass(Base):
        __tablename__ = 'my_table'
        __table_args__ = {"implicit_returning": False}

.. seealso::

    :ref:`cx_oracle_returning` - additional cx_oracle-specific restrictions on
    implicit returning.

ON UPDATE CASCADE
-----------------

Oracle doesn't have native ON UPDATE CASCADE functionality.  A trigger based
solution is available at
http://asktom.oracle.com/tkyte/update_cascade/index.html .

When using the SQLAlchemy ORM, the ORM has limited ability to manually issue
cascading updates - specify ForeignKey objects using the
"deferrable=True, initially='deferred'" keyword arguments,
and specify "passive_updates=False" on each relationship().

Oracle 8 Compatibility
----------------------

When Oracle 8 is detected, the dialect internally configures itself to the
following behaviors:

* the use_ansi flag is set to False.  This has the effect of converting all
  JOIN phrases into the WHERE clause, and in the case of LEFT OUTER JOIN
  makes use of Oracle's (+) operator.

* the NVARCHAR2 and NCLOB datatypes are no longer generated as DDL when
  the :class:`~sqlalchemy.types.Unicode` is used - VARCHAR2 and CLOB are
  issued instead.   This because these types don't seem to work correctly on
  Oracle 8 even though they are available.  The
  :class:`~sqlalchemy.types.NVARCHAR` and
  :class:`~sqlalchemy.dialects.oracle.NCLOB` types will always generate
  NVARCHAR2 and NCLOB.

* the "native unicode" mode is disabled when using cx_oracle, i.e. SQLAlchemy
  encodes all Python unicode objects to "string" before passing in as bind
  parameters.

Synonym/DBLINK Reflection
-------------------------

When using reflection with Table objects, the dialect can optionally search
for tables indicated by synonyms, either in local or remote schemas or
accessed over DBLINK, by passing the flag ``oracle_resolve_synonyms=True`` as
a keyword argument to the :class:`_schema.Table` construct::

    some_table = Table('some_table', autoload=True,
                                autoload_with=some_engine,
                                oracle_resolve_synonyms=True)

When this flag is set, the given name (such as ``some_table`` above) will
be searched not just in the ``ALL_TABLES`` view, but also within the
``ALL_SYNONYMS`` view to see if this name is actually a synonym to another
name.  If the synonym is located and refers to a DBLINK, the oracle dialect
knows how to locate the table's information using DBLINK syntax(e.g.
``@dblink``).

``oracle_resolve_synonyms`` is accepted wherever reflection arguments are
accepted, including methods such as :meth:`_schema.MetaData.reflect` and
:meth:`_reflection.Inspector.get_columns`.

If synonyms are not in use, this flag should be left disabled.

.. _oracle_constraint_reflection:

Constraint Reflection
---------------------

The Oracle dialect can return information about foreign key, unique, and
CHECK constraints, as well as indexes on tables.

Raw information regarding these constraints can be acquired using
:meth:`_reflection.Inspector.get_foreign_keys`,
:meth:`_reflection.Inspector.get_unique_constraints`,
:meth:`_reflection.Inspector.get_check_constraints`, and
:meth:`_reflection.Inspector.get_indexes`.

.. versionchanged:: 1.2  The Oracle dialect can now reflect UNIQUE and
   CHECK constraints.

When using reflection at the :class:`_schema.Table` level, the
:class:`_schema.Table`
will also include these constraints.

Note the following caveats:

* When using the :meth:`_reflection.Inspector.get_check_constraints` method,
  Oracle
  builds a special "IS NOT NULL" constraint for columns that specify
  "NOT NULL".  This constraint is **not** returned by default; to include
  the "IS NOT NULL" constraints, pass the flag ``include_all=True``::

      from sqlalchemy import create_engine, inspect

      engine = create_engine("oracle+cx_oracle://s:t@dsn")
      inspector = inspect(engine)
      all_check_constraints = inspector.get_check_constraints(
          "some_table", include_all=True)

* in most cases, when reflecting a :class:`_schema.Table`,
  a UNIQUE constraint will
  **not** be available as a :class:`.UniqueConstraint` object, as Oracle
  mirrors unique constraints with a UNIQUE index in most cases (the exception
  seems to be when two or more unique constraints represent the same columns);
  the :class:`_schema.Table` will instead represent these using
  :class:`.Index`
  with the ``unique=True`` flag set.

* Oracle creates an implicit index for the primary key of a table; this index
  is **excluded** from all index results.

* the list of columns reflected for an index will not include column names
  that start with SYS_NC.

Table names with SYSTEM/SYSAUX tablespaces
-------------------------------------------

The :meth:`_reflection.Inspector.get_table_names` and
:meth:`_reflection.Inspector.get_temp_table_names`
methods each return a list of table names for the current engine. These methods
are also part of the reflection which occurs within an operation such as
:meth:`_schema.MetaData.reflect`.  By default,
these operations exclude the ``SYSTEM``
and ``SYSAUX`` tablespaces from the operation.   In order to change this, the
default list of tablespaces excluded can be changed at the engine level using
the ``exclude_tablespaces`` parameter::

    # exclude SYSAUX and SOME_TABLESPACE, but not SYSTEM
    e = create_engine(
      "oracle://scott:tiger@xe",
      exclude_tablespaces=["SYSAUX", "SOME_TABLESPACE"])

.. versionadded:: 1.1

DateTime Compatibility
----------------------

Oracle has no datatype known as ``DATETIME``, it instead has only ``DATE``,
which can actually store a date and time value.  For this reason, the Oracle
dialect provides a type :class:`_oracle.DATE` which is a subclass of
:class:`.DateTime`.   This type has no special behavior, and is only
present as a "marker" for this type; additionally, when a database column
is reflected and the type is reported as ``DATE``, the time-supporting
:class:`_oracle.DATE` type is used.

.. versionchanged:: 0.9.4 Added :class:`_oracle.DATE` to subclass
   :class:`.DateTime`.  This is a change as previous versions
   would reflect a ``DATE`` column as :class:`_types.DATE`, which subclasses
   :class:`.Date`.   The only significance here is for schemes that are
   examining the type of column for use in special Python translations or
   for migrating schemas to other database backends.

.. _oracle_table_options:

Oracle Table Options
-------------------------

The CREATE TABLE phrase supports the following options with Oracle
in conjunction with the :class:`_schema.Table` construct:


* ``ON COMMIT``::

    Table(
        "some_table", metadata, ...,
        prefixes=['GLOBAL TEMPORARY'], oracle_on_commit='PRESERVE ROWS')

.. versionadded:: 1.0.0

* ``COMPRESS``::

    Table('mytable', metadata, Column('data', String(32)),
        oracle_compress=True)

    Table('mytable', metadata, Column('data', String(32)),
        oracle_compress=6)

   The ``oracle_compress`` parameter accepts either an integer compression
   level, or ``True`` to use the default compression level.

.. versionadded:: 1.0.0

.. _oracle_index_options:

Oracle Specific Index Options
-----------------------------

Bitmap Indexes
~~~~~~~~~~~~~~

You can specify the ``oracle_bitmap`` parameter to create a bitmap index
instead of a B-tree index::

    Index('my_index', my_table.c.data, oracle_bitmap=True)

Bitmap indexes cannot be unique and cannot be compressed. SQLAlchemy will not
check for such limitations, only the database will.

.. versionadded:: 1.0.0

Index compression
~~~~~~~~~~~~~~~~~

Oracle has a more efficient storage mode for indexes containing lots of
repeated values. Use the ``oracle_compress`` parameter to turn on key
compression::

    Index('my_index', my_table.c.data, oracle_compress=True)

    Index('my_index', my_table.c.data1, my_table.c.data2, unique=True,
           oracle_compress=1)

The ``oracle_compress`` parameter accepts either an integer specifying the
number of prefix columns to compress, or ``True`` to use the default (all
columns for non-unique indexes, all but the last column for unique indexes).

.. versionadded:: 1.0.0

"""
RESERVED_WORDS = set("SHARE RAW DROP BETWEEN FROM DESC OPTION PRIOR LONG THEN " "DEFAULT ALTER IS INTO MINUS INTEGER NUMBER GRANT IDENTIFIED " "ALL TO ORDER ON FLOAT DATE HAVING CLUSTER NOWAIT RESOURCE " "ANY TABLE INDEX FOR UPDATE WHERE CHECK SMALLINT WITH DELETE " "BY ASC REVOKE LIKE SIZE RENAME NOCOMPRESS NULL GROUP VALUES " "AS IN VIEW EXCLUSIVE COMPRESS SYNONYM SELECT INSERT EXISTS " "NOT TRIGGER ELSE CREATE INTERSECT PCTFREE DISTINCT USER " "CONNECT SET MODE OF UNIQUE VARCHAR2 VARCHAR LOCK OR CHAR " "DECIMAL UNION PUBLIC AND START UID COMMENT CURRENT LEVEL".split())
NO_ARG_FNS = set("UID CURRENT_DATE SYSDATE USER " "CURRENT_TIME CURRENT_TIMESTAMP".split())
class RAW(sqltypes._Binary):
    __visit_name__ = ...


OracleRaw = RAW
class NCLOB(sqltypes.Text):
    __visit_name__ = ...


class VARCHAR2(VARCHAR):
    __visit_name__ = ...


NVARCHAR2 = NVARCHAR
class NUMBER(sqltypes.Numeric, sqltypes.Integer):
    __visit_name__ = ...
    def __init__(self, precision=..., scale=..., asdecimal=...) -> None:
        ...
    
    def adapt(self, impltype):
        ...
    


class DOUBLE_PRECISION(sqltypes.Float):
    __visit_name__ = ...


class BINARY_DOUBLE(sqltypes.Float):
    __visit_name__ = ...


class BINARY_FLOAT(sqltypes.Float):
    __visit_name__ = ...


class BFILE(sqltypes.LargeBinary):
    __visit_name__ = ...


class LONG(sqltypes.Text):
    __visit_name__ = ...


class DATE(sqltypes.DateTime):
    """Provide the oracle DATE type.

    This type has no special Python behavior, except that it subclasses
    :class:`_types.DateTime`; this is to suit the fact that the Oracle
    ``DATE`` type supports a time value.

    .. versionadded:: 0.9.4

    """
    __visit_name__ = ...


class INTERVAL(sqltypes.TypeEngine):
    __visit_name__ = ...
    def __init__(self, day_precision=..., second_precision=...) -> None:
        """Construct an INTERVAL.

        Note that only DAY TO SECOND intervals are currently supported.
        This is due to a lack of support for YEAR TO MONTH intervals
        within available DBAPIs (cx_oracle and zxjdbc).

        :param day_precision: the day precision value.  this is the number of
          digits to store for the day field.  Defaults to "2"
        :param second_precision: the second precision value.  this is the
          number of digits to store for the fractional seconds field.
          Defaults to "6".

        """
        ...
    


class ROWID(sqltypes.TypeEngine):
    """Oracle ROWID type.

    When used in a cast() or similar, generates ROWID.

    """
    __visit_name__ = ...


class _OracleBoolean(sqltypes.Boolean):
    def get_dbapi_type(self, dbapi):
        ...
    


colspecs = { sqltypes.Boolean: _OracleBoolean,sqltypes.Interval: INTERVAL,sqltypes.DateTime: DATE }
ischema_names = { "VARCHAR2": VARCHAR,"NVARCHAR2": NVARCHAR,"CHAR": CHAR,"NCHAR": NCHAR,"DATE": DATE,"NUMBER": NUMBER,"BLOB": BLOB,"BFILE": BFILE,"CLOB": CLOB,"NCLOB": NCLOB,"TIMESTAMP": TIMESTAMP,"TIMESTAMP WITH TIME ZONE": TIMESTAMP,"INTERVAL DAY TO SECOND": INTERVAL,"RAW": RAW,"FLOAT": FLOAT,"DOUBLE PRECISION": DOUBLE_PRECISION,"LONG": LONG,"BINARY_DOUBLE": BINARY_DOUBLE,"BINARY_FLOAT": BINARY_FLOAT }
class OracleTypeCompiler(compiler.GenericTypeCompiler):
    def visit_datetime(self, type_, **kw):
        ...
    
    def visit_float(self, type_, **kw):
        ...
    
    def visit_unicode(self, type_, **kw):
        ...
    
    def visit_INTERVAL(self, type_, **kw):
        ...
    
    def visit_LONG(self, type_, **kw):
        ...
    
    def visit_TIMESTAMP(self, type_, **kw):
        ...
    
    def visit_DOUBLE_PRECISION(self, type_, **kw):
        ...
    
    def visit_BINARY_DOUBLE(self, type_, **kw):
        ...
    
    def visit_BINARY_FLOAT(self, type_, **kw):
        ...
    
    def visit_FLOAT(self, type_, **kw):
        ...
    
    def visit_NUMBER(self, type_, **kw):
        ...
    
    def visit_string(self, type_, **kw):
        ...
    
    def visit_VARCHAR2(self, type_, **kw):
        ...
    
    def visit_NVARCHAR2(self, type_, **kw):
        ...
    
    visit_NVARCHAR = ...
    def visit_VARCHAR(self, type_, **kw):
        ...
    
    def visit_text(self, type_, **kw):
        ...
    
    def visit_unicode_text(self, type_, **kw):
        ...
    
    def visit_large_binary(self, type_, **kw):
        ...
    
    def visit_big_integer(self, type_, **kw):
        ...
    
    def visit_boolean(self, type_, **kw):
        ...
    
    def visit_RAW(self, type_, **kw):
        ...
    
    def visit_ROWID(self, type_, **kw):
        ...
    


class OracleCompiler(compiler.SQLCompiler):
    """Oracle compiler modifies the lexical structure of Select
    statements to work under non-ANSI configured Oracle databases, if
    the use_ansi flag is False.
    """
    compound_keywords = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def visit_mod_binary(self, binary, operator, **kw):
        ...
    
    def visit_now_func(self, fn, **kw):
        ...
    
    def visit_char_length_func(self, fn, **kw):
        ...
    
    def visit_match_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_true(self, expr, **kw):
        ...
    
    def visit_false(self, expr, **kw):
        ...
    
    def get_cte_preamble(self, recursive):
        ...
    
    def get_select_hint_text(self, byfroms):
        ...
    
    def function_argspec(self, fn, **kw):
        ...
    
    def default_from(self):
        """Called when a ``SELECT`` statement has no froms,
        and no ``FROM`` clause is to be appended.

        The Oracle compiler tacks a "FROM DUAL" to the statement.
        """
        ...
    
    def visit_join(self, join, **kwargs):
        ...
    
    def visit_outer_join_column(self, vc, **kw):
        ...
    
    def visit_sequence(self, seq, **kw):
        ...
    
    def get_render_as_alias_suffix(self, alias_name_text):
        """Oracle doesn't like ``FROM table AS alias``"""
        ...
    
    def returning_clause(self, stmt, returning_cols):
        ...
    
    def visit_select(self, select, **kwargs):
        """Look for ``LIMIT`` and OFFSET in a select statement, and if
        so tries to wrap it in a subquery with ``rownum`` criterion.
        """
        ...
    
    def limit_clause(self, select, **kw):
        ...
    
    def visit_empty_set_expr(self, type_):
        ...
    
    def for_update_clause(self, select, **kw):
        ...
    
    def visit_is_distinct_from_binary(self, binary, operator, **kw):
        ...
    
    def visit_isnot_distinct_from_binary(self, binary, operator, **kw):
        ...
    


class OracleDDLCompiler(compiler.DDLCompiler):
    def define_constraint_cascades(self, constraint):
        ...
    
    def visit_drop_table_comment(self, drop):
        ...
    
    def visit_create_index(self, create):
        ...
    
    def post_create_table(self, table):
        ...
    
    def visit_computed_column(self, generated):
        ...
    


class OracleIdentifierPreparer(compiler.IdentifierPreparer):
    reserved_words = ...
    illegal_initial_characters = ...
    def format_savepoint(self, savepoint):
        ...
    


class OracleExecutionContext(default.DefaultExecutionContext):
    def fire_sequence(self, seq, type_):
        ...
    


class OracleDialect(default.DefaultDialect):
    name = ...
    supports_alter = ...
    supports_unicode_statements = ...
    supports_unicode_binds = ...
    max_identifier_length = ...
    supports_simple_order_by_label = ...
    cte_follows_insert = ...
    supports_sequences = ...
    sequences_optional = ...
    postfetch_lastrowid = ...
    default_paramstyle = ...
    colspecs = ...
    ischema_names = ...
    requires_name_normalize = ...
    supports_comments = ...
    supports_default_values = ...
    supports_empty_insert = ...
    statement_compiler = ...
    ddl_compiler = ...
    type_compiler = ...
    preparer = ...
    execution_ctx_cls = ...
    reflection_options = ...
    _use_nchar_for_unicode = ...
    construct_arguments = ...
    def __init__(self, use_ansi=..., optimize_limits=..., use_binds_for_limits=..., use_nchar_for_unicode=..., exclude_tablespaces=..., **kwargs) -> None:
        ...
    
    def initialize(self, connection):
        ...
    
    def do_release_savepoint(self, connection, name):
        ...
    
    _isolation_lookup = ...
    def get_isolation_level(self, connection):
        ...
    
    def set_isolation_level(self, connection, level):
        ...
    
    def has_table(self, connection, table_name, schema=...):
        ...
    
    def has_sequence(self, connection, sequence_name, schema=...):
        ...
    
    @reflection.cache
    def get_schema_names(self, connection, **kw):
        ...
    
    @reflection.cache
    def get_table_names(self, connection, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_temp_table_names(self, connection, **kw):
        ...
    
    @reflection.cache
    def get_view_names(self, connection, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_table_options(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_columns(self, connection, table_name, schema=..., **kw):
        """

        kw arguments can be:

            oracle_resolve_synonyms

            dblink

        """
        ...
    
    @reflection.cache
    def get_table_comment(self, connection, table_name, schema=..., resolve_synonyms=..., dblink=..., **kw):
        ...
    
    @reflection.cache
    def get_indexes(self, connection, table_name, schema=..., resolve_synonyms=..., dblink=..., **kw):
        ...
    
    @reflection.cache
    def get_pk_constraint(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_foreign_keys(self, connection, table_name, schema=..., **kw):
        """

        kw arguments can be:

            oracle_resolve_synonyms

            dblink

        """
        ...
    
    @reflection.cache
    def get_unique_constraints(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_view_definition(self, connection, view_name, schema=..., resolve_synonyms=..., dblink=..., **kw):
        ...
    
    @reflection.cache
    def get_check_constraints(self, connection, table_name, schema=..., include_all=..., **kw):
        ...
    


class _OuterJoinColumn(sql.ClauseElement):
    __visit_name__ = ...
    def __init__(self, column) -> None:
        ...
    


