"""
This type stub file was generated by pyright.
"""

import re
from . import array as _array, hstore as _hstore, json as _json, ranges as _ranges
from ... import schema
from ...engine import default, reflection
from ...sql import compiler, sqltypes
from ...sql.ddl import DDLBase
from ...types import BIGINT, BOOLEAN, CHAR, DATE, FLOAT, INTEGER, NUMERIC, REAL, SMALLINT, TEXT, VARCHAR

r"""
.. dialect:: postgresql
    :name: PostgreSQL

.. _postgresql_sequences:

Sequences/SERIAL/IDENTITY
-------------------------

PostgreSQL supports sequences, and SQLAlchemy uses these as the default means
of creating new primary key values for integer-based primary key columns. When
creating tables, SQLAlchemy will issue the ``SERIAL`` datatype for
integer-based primary key columns, which generates a sequence and server side
default corresponding to the column.

To specify a specific named sequence to be used for primary key generation,
use the :func:`~sqlalchemy.schema.Sequence` construct::

    Table('sometable', metadata,
            Column('id', Integer, Sequence('some_id_seq'), primary_key=True)
        )

When SQLAlchemy issues a single INSERT statement, to fulfill the contract of
having the "last insert identifier" available, a RETURNING clause is added to
the INSERT statement which specifies the primary key columns should be
returned after the statement completes. The RETURNING functionality only takes
place if PostgreSQL 8.2 or later is in use. As a fallback approach, the
sequence, whether specified explicitly or implicitly via ``SERIAL``, is
executed independently beforehand, the returned value to be used in the
subsequent insert. Note that when an
:func:`~sqlalchemy.sql.expression.insert()` construct is executed using
"executemany" semantics, the "last inserted identifier" functionality does not
apply; no RETURNING clause is emitted nor is the sequence pre-executed in this
case.

To force the usage of RETURNING by default off, specify the flag
``implicit_returning=False`` to :func:`_sa.create_engine`.

PostgreSQL 10 IDENTITY columns
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

PostgreSQL 10 has a new IDENTITY feature that supersedes the use of SERIAL.
Built-in support for rendering of IDENTITY is not available yet, however the
following compilation hook may be used to replace occurrences of SERIAL with
IDENTITY::

    from sqlalchemy.schema import CreateColumn
    from sqlalchemy.ext.compiler import compiles


    @compiles(CreateColumn, 'postgresql')
    def use_identity(element, compiler, **kw):
        text = compiler.visit_create_column(element, **kw)
        text = text.replace("SERIAL", "INT GENERATED BY DEFAULT AS IDENTITY")
        return text

Using the above, a table such as::

    t = Table(
        't', m,
        Column('id', Integer, primary_key=True),
        Column('data', String)
    )

Will generate on the backing database as::

    CREATE TABLE t (
        id INT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
        data VARCHAR,
        PRIMARY KEY (id)
    )

.. _postgresql_isolation_level:

Transaction Isolation Level
---------------------------

Most SQLAlchemy dialects support setting of transaction isolation level
using the :paramref:`_sa.create_engine.execution_options` parameter
at the :func:`_sa.create_engine` level, and at the :class:`_engine.Connection`
level via the :paramref:`.Connection.execution_options.isolation_level`
parameter.

For PostgreSQL dialects, this feature works either by making use of the
DBAPI-specific features, such as psycopg2's isolation level flags which will
embed the isolation level setting inline with the ``"BEGIN"`` statement, or for
DBAPIs with no direct support by emitting ``SET SESSION CHARACTERISTICS AS
TRANSACTION ISOLATION LEVEL <level>`` ahead of the ``"BEGIN"`` statement
emitted by the DBAPI.   For the special AUTOCOMMIT isolation level,
DBAPI-specific techniques are used which is typically an ``.autocommit``
flag on the DBAPI connection object.

To set isolation level using :func:`_sa.create_engine`::

    engine = create_engine(
        "postgresql+pg8000://scott:tiger@localhost/test",
        execution_options={
            "isolation_level": "REPEATABLE READ"
        }
    )

To set using per-connection execution options::

    with engine.connect() as conn:
        conn = conn.execution_options(
            isolation_level="REPEATABLE READ"
        )
        with conn.begin():
            # ... work with transaction

Valid values for ``isolation_level`` on most PostgreSQL dialects include:

* ``READ COMMITTED``
* ``READ UNCOMMITTED``
* ``REPEATABLE READ``
* ``SERIALIZABLE``
* ``AUTOCOMMIT``

.. seealso::

    :ref:`dbapi_autocommit`

    :ref:`psycopg2_isolation_level`

    :ref:`pg8000_isolation_level`

.. _postgresql_schema_reflection:

Remote-Schema Table Introspection and PostgreSQL search_path
------------------------------------------------------------

**TL;DR;**: keep the ``search_path`` variable set to its default of ``public``,
name schemas **other** than ``public`` explicitly within ``Table`` definitions.

The PostgreSQL dialect can reflect tables from any schema.  The
:paramref:`_schema.Table.schema` argument, or alternatively the
:paramref:`.MetaData.reflect.schema` argument determines which schema will
be searched for the table or tables.   The reflected :class:`_schema.Table`
objects
will in all cases retain this ``.schema`` attribute as was specified.
However, with regards to tables which these :class:`_schema.Table`
objects refer to
via foreign key constraint, a decision must be made as to how the ``.schema``
is represented in those remote tables, in the case where that remote
schema name is also a member of the current
`PostgreSQL search path
<http://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH>`_.

By default, the PostgreSQL dialect mimics the behavior encouraged by
PostgreSQL's own ``pg_get_constraintdef()`` builtin procedure.  This function
returns a sample definition for a particular foreign key constraint,
omitting the referenced schema name from that definition when the name is
also in the PostgreSQL schema search path.  The interaction below
illustrates this behavior::

    test=> CREATE TABLE test_schema.referred(id INTEGER PRIMARY KEY);
    CREATE TABLE
    test=> CREATE TABLE referring(
    test(>         id INTEGER PRIMARY KEY,
    test(>         referred_id INTEGER REFERENCES test_schema.referred(id));
    CREATE TABLE
    test=> SET search_path TO public, test_schema;
    test=> SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM
    test-> pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
    test-> ON n.oid = c.relnamespace
    test-> JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
    test-> WHERE c.relname='referring' AND r.contype = 'f'
    test-> ;
                   pg_get_constraintdef
    ---------------------------------------------------
     FOREIGN KEY (referred_id) REFERENCES referred(id)
    (1 row)

Above, we created a table ``referred`` as a member of the remote schema
``test_schema``, however when we added ``test_schema`` to the
PG ``search_path`` and then asked ``pg_get_constraintdef()`` for the
``FOREIGN KEY`` syntax, ``test_schema`` was not included in the output of
the function.

On the other hand, if we set the search path back to the typical default
of ``public``::

    test=> SET search_path TO public;
    SET

The same query against ``pg_get_constraintdef()`` now returns the fully
schema-qualified name for us::

    test=> SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM
    test-> pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n
    test-> ON n.oid = c.relnamespace
    test-> JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid
    test-> WHERE c.relname='referring' AND r.contype = 'f';
                         pg_get_constraintdef
    ---------------------------------------------------------------
     FOREIGN KEY (referred_id) REFERENCES test_schema.referred(id)
    (1 row)

SQLAlchemy will by default use the return value of ``pg_get_constraintdef()``
in order to determine the remote schema name.  That is, if our ``search_path``
were set to include ``test_schema``, and we invoked a table
reflection process as follows::

    >>> from sqlalchemy import Table, MetaData, create_engine
    >>> engine = create_engine("postgresql://scott:tiger@localhost/test")
    >>> with engine.connect() as conn:
    ...     conn.execute("SET search_path TO test_schema, public")
    ...     meta = MetaData()
    ...     referring = Table('referring', meta,
    ...                       autoload=True, autoload_with=conn)
    ...
    <sqlalchemy.engine.result.ResultProxy object at 0x101612ed0>

The above process would deliver to the :attr:`_schema.MetaData.tables`
collection
``referred`` table named **without** the schema::

    >>> meta.tables['referred'].schema is None
    True

To alter the behavior of reflection such that the referred schema is
maintained regardless of the ``search_path`` setting, use the
``postgresql_ignore_search_path`` option, which can be specified as a
dialect-specific argument to both :class:`_schema.Table` as well as
:meth:`_schema.MetaData.reflect`::

    >>> with engine.connect() as conn:
    ...     conn.execute("SET search_path TO test_schema, public")
    ...     meta = MetaData()
    ...     referring = Table('referring', meta, autoload=True,
    ...                       autoload_with=conn,
    ...                       postgresql_ignore_search_path=True)
    ...
    <sqlalchemy.engine.result.ResultProxy object at 0x1016126d0>

We will now have ``test_schema.referred`` stored as schema-qualified::

    >>> meta.tables['test_schema.referred'].schema
    'test_schema'

.. sidebar:: Best Practices for PostgreSQL Schema reflection

    The description of PostgreSQL schema reflection behavior is complex, and
    is the product of many years of dealing with widely varied use cases and
    user preferences. But in fact, there's no need to understand any of it if
    you just stick to the simplest use pattern: leave the ``search_path`` set
    to its default of ``public`` only, never refer to the name ``public`` as
    an explicit schema name otherwise, and refer to all other schema names
    explicitly when building up a :class:`_schema.Table` object.  The options
    described here are only for those users who can't, or prefer not to, stay
    within these guidelines.

Note that **in all cases**, the "default" schema is always reflected as
``None``. The "default" schema on PostgreSQL is that which is returned by the
PostgreSQL ``current_schema()`` function.  On a typical PostgreSQL
installation, this is the name ``public``.  So a table that refers to another
which is in the ``public`` (i.e. default) schema will always have the
``.schema`` attribute set to ``None``.

.. versionadded:: 0.9.2 Added the ``postgresql_ignore_search_path``
   dialect-level option accepted by :class:`_schema.Table` and
   :meth:`_schema.MetaData.reflect`.


.. seealso::

    `The Schema Search Path
    <http://www.postgresql.org/docs/9.0/static/ddl-schemas.html#DDL-SCHEMAS-PATH>`_
    - on the PostgreSQL website.

INSERT/UPDATE...RETURNING
-------------------------

The dialect supports PG 8.2's ``INSERT..RETURNING``, ``UPDATE..RETURNING`` and
``DELETE..RETURNING`` syntaxes.   ``INSERT..RETURNING`` is used by default
for single-row INSERT statements in order to fetch newly generated
primary key identifiers.   To specify an explicit ``RETURNING`` clause,
use the :meth:`._UpdateBase.returning` method on a per-statement basis::

    # INSERT..RETURNING
    result = table.insert().returning(table.c.col1, table.c.col2).\
        values(name='foo')
    print(result.fetchall())

    # UPDATE..RETURNING
    result = table.update().returning(table.c.col1, table.c.col2).\
        where(table.c.name=='foo').values(name='bar')
    print(result.fetchall())

    # DELETE..RETURNING
    result = table.delete().returning(table.c.col1, table.c.col2).\
        where(table.c.name=='foo')
    print(result.fetchall())

.. _postgresql_insert_on_conflict:

INSERT...ON CONFLICT (Upsert)
------------------------------

Starting with version 9.5, PostgreSQL allows "upserts" (update or insert) of
rows into a table via the ``ON CONFLICT`` clause of the ``INSERT`` statement. A
candidate row will only be inserted if that row does not violate any unique
constraints.  In the case of a unique constraint violation, a secondary action
can occur which can be either "DO UPDATE", indicating that the data in the
target row should be updated, or "DO NOTHING", which indicates to silently skip
this row.

Conflicts are determined using existing unique constraints and indexes.  These
constraints may be identified either using their name as stated in DDL,
or they may be *inferred* by stating the columns and conditions that comprise
the indexes.

SQLAlchemy provides ``ON CONFLICT`` support via the PostgreSQL-specific
:func:`_postgresql.insert()` function, which provides
the generative methods :meth:`~.postgresql.Insert.on_conflict_do_update`
and :meth:`~.postgresql.Insert.on_conflict_do_nothing`::

    from sqlalchemy.dialects.postgresql import insert

    insert_stmt = insert(my_table).values(
        id='some_existing_id',
        data='inserted value')

    do_nothing_stmt = insert_stmt.on_conflict_do_nothing(
        index_elements=['id']
    )

    conn.execute(do_nothing_stmt)

    do_update_stmt = insert_stmt.on_conflict_do_update(
        constraint='pk_my_table',
        set_=dict(data='updated value')
    )

    conn.execute(do_update_stmt)

Both methods supply the "target" of the conflict using either the
named constraint or by column inference:

* The :paramref:`.Insert.on_conflict_do_update.index_elements` argument
  specifies a sequence containing string column names, :class:`_schema.Column`
  objects, and/or SQL expression elements, which would identify a unique
  index::

    do_update_stmt = insert_stmt.on_conflict_do_update(
        index_elements=['id'],
        set_=dict(data='updated value')
    )

    do_update_stmt = insert_stmt.on_conflict_do_update(
        index_elements=[my_table.c.id],
        set_=dict(data='updated value')
    )

* When using :paramref:`.Insert.on_conflict_do_update.index_elements` to
  infer an index, a partial index can be inferred by also specifying the
  use the :paramref:`.Insert.on_conflict_do_update.index_where` parameter::

    from sqlalchemy.dialects.postgresql import insert

    stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')
    stmt = stmt.on_conflict_do_update(
        index_elements=[my_table.c.user_email],
        index_where=my_table.c.user_email.like('%@gmail.com'),
        set_=dict(data=stmt.excluded.data)
        )
    conn.execute(stmt)

* The :paramref:`.Insert.on_conflict_do_update.constraint` argument is
  used to specify an index directly rather than inferring it.  This can be
  the name of a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX::

    do_update_stmt = insert_stmt.on_conflict_do_update(
        constraint='my_table_idx_1',
        set_=dict(data='updated value')
    )

    do_update_stmt = insert_stmt.on_conflict_do_update(
        constraint='my_table_pk',
        set_=dict(data='updated value')
    )

* The :paramref:`.Insert.on_conflict_do_update.constraint` argument may
  also refer to a SQLAlchemy construct representing a constraint,
  e.g. :class:`.UniqueConstraint`, :class:`.PrimaryKeyConstraint`,
  :class:`.Index`, or :class:`.ExcludeConstraint`.   In this use,
  if the constraint has a name, it is used directly.  Otherwise, if the
  constraint is unnamed, then inference will be used, where the expressions
  and optional WHERE clause of the constraint will be spelled out in the
  construct.  This use is especially convenient
  to refer to the named or unnamed primary key of a :class:`_schema.Table`
  using the
  :attr:`_schema.Table.primary_key` attribute::

    do_update_stmt = insert_stmt.on_conflict_do_update(
        constraint=my_table.primary_key,
        set_=dict(data='updated value')
    )

``ON CONFLICT...DO UPDATE`` is used to perform an update of the already
existing row, using any combination of new values as well as values
from the proposed insertion.   These values are specified using the
:paramref:`.Insert.on_conflict_do_update.set_` parameter.  This
parameter accepts a dictionary which consists of direct values
for UPDATE::

    from sqlalchemy.dialects.postgresql import insert

    stmt = insert(my_table).values(id='some_id', data='inserted value')
    do_update_stmt = stmt.on_conflict_do_update(
        index_elements=['id'],
        set_=dict(data='updated value')
        )
    conn.execute(do_update_stmt)

.. warning::

    The :meth:`_expression.Insert.on_conflict_do_update`
    method does **not** take into
    account Python-side default UPDATE values or generation functions, e.g.
    those specified using :paramref:`_schema.Column.onupdate`.
    These values will not be exercised for an ON CONFLICT style of UPDATE,
    unless they are manually specified in the
    :paramref:`.Insert.on_conflict_do_update.set_` dictionary.

In order to refer to the proposed insertion row, the special alias
:attr:`~.postgresql.Insert.excluded` is available as an attribute on
the :class:`_postgresql.Insert` object; this object is a
:class:`_expression.ColumnCollection`
which alias contains all columns of the target
table::

    from sqlalchemy.dialects.postgresql import insert

    stmt = insert(my_table).values(
        id='some_id',
        data='inserted value',
        author='jlh')
    do_update_stmt = stmt.on_conflict_do_update(
        index_elements=['id'],
        set_=dict(data='updated value', author=stmt.excluded.author)
        )
    conn.execute(do_update_stmt)

The :meth:`_expression.Insert.on_conflict_do_update` method also accepts
a WHERE clause using the :paramref:`.Insert.on_conflict_do_update.where`
parameter, which will limit those rows which receive an UPDATE::

    from sqlalchemy.dialects.postgresql import insert

    stmt = insert(my_table).values(
        id='some_id',
        data='inserted value',
        author='jlh')
    on_update_stmt = stmt.on_conflict_do_update(
        index_elements=['id'],
        set_=dict(data='updated value', author=stmt.excluded.author)
        where=(my_table.c.status == 2)
        )
    conn.execute(on_update_stmt)

``ON CONFLICT`` may also be used to skip inserting a row entirely
if any conflict with a unique or exclusion constraint occurs; below
this is illustrated using the
:meth:`~.postgresql.Insert.on_conflict_do_nothing` method::

    from sqlalchemy.dialects.postgresql import insert

    stmt = insert(my_table).values(id='some_id', data='inserted value')
    stmt = stmt.on_conflict_do_nothing(index_elements=['id'])
    conn.execute(stmt)

If ``DO NOTHING`` is used without specifying any columns or constraint,
it has the effect of skipping the INSERT for any unique or exclusion
constraint violation which occurs::

    from sqlalchemy.dialects.postgresql import insert

    stmt = insert(my_table).values(id='some_id', data='inserted value')
    stmt = stmt.on_conflict_do_nothing()
    conn.execute(stmt)

.. versionadded:: 1.1 Added support for PostgreSQL ON CONFLICT clauses

.. seealso::

    `INSERT .. ON CONFLICT
    <http://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT>`_
    - in the PostgreSQL documentation.

.. _postgresql_match:

Full Text Search
----------------

SQLAlchemy makes available the PostgreSQL ``@@`` operator via the
:meth:`_expression.ColumnElement.match`
method on any textual column expression.
On a PostgreSQL dialect, an expression like the following::

    select([sometable.c.text.match("search string")])

will emit to the database::

    SELECT text @@ to_tsquery('search string') FROM table

The PostgreSQL text search functions such as ``to_tsquery()``
and ``to_tsvector()`` are available
explicitly using the standard :data:`.func` construct.  For example::

    select([
        func.to_tsvector('fat cats ate rats').match('cat & rat')
    ])

Emits the equivalent of::

    SELECT to_tsvector('fat cats ate rats') @@ to_tsquery('cat & rat')

The :class:`_postgresql.TSVECTOR` type can provide for explicit CAST::

    from sqlalchemy.dialects.postgresql import TSVECTOR
    from sqlalchemy import select, cast
    select([cast("some text", TSVECTOR)])

produces a statement equivalent to::

    SELECT CAST('some text' AS TSVECTOR) AS anon_1

Full Text Searches in PostgreSQL are influenced by a combination of: the
PostgreSQL setting of ``default_text_search_config``, the ``regconfig`` used
to build the GIN/GiST indexes, and the ``regconfig`` optionally passed in
during a query.

When performing a Full Text Search against a column that has a GIN or
GiST index that is already pre-computed (which is common on full text
searches) one may need to explicitly pass in a particular PostgreSQL
``regconfig`` value to ensure the query-planner utilizes the index and does
not re-compute the column on demand.

In order to provide for this explicit query planning, or to use different
search strategies, the ``match`` method accepts a ``postgresql_regconfig``
keyword argument::

    select([mytable.c.id]).where(
        mytable.c.title.match('somestring', postgresql_regconfig='english')
    )

Emits the equivalent of::

    SELECT mytable.id FROM mytable
    WHERE mytable.title @@ to_tsquery('english', 'somestring')

One can also specifically pass in a `'regconfig'` value to the
``to_tsvector()`` command as the initial argument::

    select([mytable.c.id]).where(
            func.to_tsvector('english', mytable.c.title )\
            .match('somestring', postgresql_regconfig='english')
        )

produces a statement equivalent to::

    SELECT mytable.id FROM mytable
    WHERE to_tsvector('english', mytable.title) @@
        to_tsquery('english', 'somestring')

It is recommended that you use the ``EXPLAIN ANALYZE...`` tool from
PostgreSQL to ensure that you are generating queries with SQLAlchemy that
take full advantage of any indexes you may have created for full text search.

FROM ONLY ...
-------------

The dialect supports PostgreSQL's ONLY keyword for targeting only a particular
table in an inheritance hierarchy. This can be used to produce the
``SELECT ... FROM ONLY``, ``UPDATE ONLY ...``, and ``DELETE FROM ONLY ...``
syntaxes. It uses SQLAlchemy's hints mechanism::

    # SELECT ... FROM ONLY ...
    result = table.select().with_hint(table, 'ONLY', 'postgresql')
    print(result.fetchall())

    # UPDATE ONLY ...
    table.update(values=dict(foo='bar')).with_hint('ONLY',
                                                   dialect_name='postgresql')

    # DELETE FROM ONLY ...
    table.delete().with_hint('ONLY', dialect_name='postgresql')


.. _postgresql_indexes:

PostgreSQL-Specific Index Options
---------------------------------

Several extensions to the :class:`.Index` construct are available, specific
to the PostgreSQL dialect.

.. _postgresql_partial_indexes:

Partial Indexes
^^^^^^^^^^^^^^^

Partial indexes add criterion to the index definition so that the index is
applied to a subset of rows.   These can be specified on :class:`.Index`
using the ``postgresql_where`` keyword argument::

  Index('my_index', my_table.c.id, postgresql_where=my_table.c.value > 10)

Operator Classes
^^^^^^^^^^^^^^^^

PostgreSQL allows the specification of an *operator class* for each column of
an index (see
http://www.postgresql.org/docs/8.3/interactive/indexes-opclass.html).
The :class:`.Index` construct allows these to be specified via the
``postgresql_ops`` keyword argument::

    Index(
        'my_index', my_table.c.id, my_table.c.data,
        postgresql_ops={
            'data': 'text_pattern_ops',
            'id': 'int4_ops'
        })

Note that the keys in the ``postgresql_ops`` dictionary are the "key" name of
the :class:`_schema.Column`, i.e. the name used to access it from the ``.c``
collection of :class:`_schema.Table`,
which can be configured to be different than
the actual name of the column as expressed in the database.

If ``postgresql_ops`` is to be used against a complex SQL expression such
as a function call, then to apply to the column it must be given a label
that is identified in the dictionary by name, e.g.::

    Index(
        'my_index', my_table.c.id,
        func.lower(my_table.c.data).label('data_lower'),
        postgresql_ops={
            'data_lower': 'text_pattern_ops',
            'id': 'int4_ops'
        })


Index Types
^^^^^^^^^^^

PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well
as the ability for users to create their own (see
http://www.postgresql.org/docs/8.3/static/indexes-types.html). These can be
specified on :class:`.Index` using the ``postgresql_using`` keyword argument::

    Index('my_index', my_table.c.data, postgresql_using='gin')

The value passed to the keyword argument will be simply passed through to the
underlying CREATE INDEX command, so it *must* be a valid index type for your
version of PostgreSQL.

.. _postgresql_index_storage:

Index Storage Parameters
^^^^^^^^^^^^^^^^^^^^^^^^

PostgreSQL allows storage parameters to be set on indexes. The storage
parameters available depend on the index method used by the index. Storage
parameters can be specified on :class:`.Index` using the ``postgresql_with``
keyword argument::

    Index('my_index', my_table.c.data, postgresql_with={"fillfactor": 50})

.. versionadded:: 1.0.6

PostgreSQL allows to define the tablespace in which to create the index.
The tablespace can be specified on :class:`.Index` using the
``postgresql_tablespace`` keyword argument::

    Index('my_index', my_table.c.data, postgresql_tablespace='my_tablespace')

.. versionadded:: 1.1

Note that the same option is available on :class:`_schema.Table` as well.

.. _postgresql_index_concurrently:

Indexes with CONCURRENTLY
^^^^^^^^^^^^^^^^^^^^^^^^^

The PostgreSQL index option CONCURRENTLY is supported by passing the
flag ``postgresql_concurrently`` to the :class:`.Index` construct::

    tbl = Table('testtbl', m, Column('data', Integer))

    idx1 = Index('test_idx1', tbl.c.data, postgresql_concurrently=True)

The above index construct will render DDL for CREATE INDEX, assuming
PostgreSQL 8.2 or higher is detected or for a connection-less dialect, as::

    CREATE INDEX CONCURRENTLY test_idx1 ON testtbl (data)

For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for
a connection-less dialect, it will emit::

    DROP INDEX CONCURRENTLY test_idx1

.. versionadded:: 1.1 support for CONCURRENTLY on DROP INDEX.  The
   CONCURRENTLY keyword is now only emitted if a high enough version
   of PostgreSQL is detected on the connection (or for a connection-less
   dialect).

When using CONCURRENTLY, the PostgreSQL database requires that the statement
be invoked outside of a transaction block.   The Python DBAPI enforces that
even for a single statement, a transaction is present, so to use this
construct, the DBAPI's "autocommit" mode must be used::

    metadata = MetaData()
    table = Table(
        "foo", metadata,
        Column("id", String))
    index = Index(
        "foo_idx", table.c.id, postgresql_concurrently=True)

    with engine.connect() as conn:
        with conn.execution_options(isolation_level='AUTOCOMMIT'):
            table.create(conn)

.. seealso::

    :ref:`postgresql_isolation_level`

.. _postgresql_index_reflection:

PostgreSQL Index Reflection
---------------------------

The PostgreSQL database creates a UNIQUE INDEX implicitly whenever the
UNIQUE CONSTRAINT construct is used.   When inspecting a table using
:class:`_reflection.Inspector`, the :meth:`_reflection.Inspector.get_indexes`
and the :meth:`_reflection.Inspector.get_unique_constraints`
will report on these
two constructs distinctly; in the case of the index, the key
``duplicates_constraint`` will be present in the index entry if it is
detected as mirroring a constraint.   When performing reflection using
``Table(..., autoload=True)``, the UNIQUE INDEX is **not** returned
in :attr:`_schema.Table.indexes` when it is detected as mirroring a
:class:`.UniqueConstraint` in the :attr:`_schema.Table.constraints` collection
.

.. versionchanged:: 1.0.0 - :class:`_schema.Table` reflection now includes
   :class:`.UniqueConstraint` objects present in the
   :attr:`_schema.Table.constraints`
   collection; the PostgreSQL backend will no longer include a "mirrored"
   :class:`.Index` construct in :attr:`_schema.Table.indexes`
   if it is detected
   as corresponding to a unique constraint.

Special Reflection Options
--------------------------

The :class:`_reflection.Inspector`
used for the PostgreSQL backend is an instance
of :class:`.PGInspector`, which offers additional methods::

    from sqlalchemy import create_engine, inspect

    engine = create_engine("postgresql+psycopg2://localhost/test")
    insp = inspect(engine)  # will be a PGInspector

    print(insp.get_enums())

.. autoclass:: PGInspector
    :members:

.. _postgresql_table_options:

PostgreSQL Table Options
------------------------

Several options for CREATE TABLE are supported directly by the PostgreSQL
dialect in conjunction with the :class:`_schema.Table` construct:

* ``TABLESPACE``::

    Table("some_table", metadata, ..., postgresql_tablespace='some_tablespace')

  The above option is also available on the :class:`.Index` construct.

* ``ON COMMIT``::

    Table("some_table", metadata, ..., postgresql_on_commit='PRESERVE ROWS')

* ``WITH OIDS``::

    Table("some_table", metadata, ..., postgresql_with_oids=True)

* ``WITHOUT OIDS``::

    Table("some_table", metadata, ..., postgresql_with_oids=False)

* ``INHERITS``::

    Table("some_table", metadata, ..., postgresql_inherits="some_supertable")

    Table("some_table", metadata, ..., postgresql_inherits=("t1", "t2", ...))

    .. versionadded:: 1.0.0

* ``PARTITION BY``::

    Table("some_table", metadata, ...,
          postgresql_partition_by='LIST (part_column)')

    .. versionadded:: 1.2.6

.. seealso::

    `PostgreSQL CREATE TABLE options
    <http://www.postgresql.org/docs/current/static/sql-createtable.html>`_

Table values, Row and Tuple objects
-----------------------------------

Row Types
^^^^^^^^^

Built-in support for rendering a ``ROW`` is not available yet, however the
:func:`_expression.tuple_` may be used in its place. Another alternative is
to use the :attr:`_sa.func` generator with ``func.ROW`` ::

    table.select().where(
        tuple_(table.c.id, table.c.fk) > (1,2)
    ).where(func.ROW(table.c.id, table.c.fk) < func.ROW(3, 7))

Will generate the row-wise comparison::

    SELECT *
    FROM table
    WHERE (id, fk) > (1, 2)
    AND ROW(id, fk) < ROW(3, 7)

.. seealso::

    `PostgreSQL Row Constructors
    <https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS>`_

    `PostgreSQL Row Constructor Comparison
    <https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON>`_

Table Types
^^^^^^^^^^^

PostgreSQL also supports passing a table as an argument to a function. This
is not available yet in sqlalchemy, however the
:func:`_expression.literal_column` function with the name of the table may be
used in its place::

    select(['*']).select_from(func.my_function(literal_column('my_table')))

Will generate the SQL::

    SELECT *
    FROM my_function(my_table)

ARRAY Types
-----------

The PostgreSQL dialect supports arrays, both as multidimensional column types
as well as array literals:

* :class:`_postgresql.ARRAY` - ARRAY datatype

* :class:`_postgresql.array` - array literal

* :func:`_postgresql.array_agg` - ARRAY_AGG SQL function

* :class:`_postgresql.aggregate_order_by` - helper for PG's ORDER BY aggregate
  function syntax.

JSON Types
----------

The PostgreSQL dialect supports both JSON and JSONB datatypes, including
psycopg2's native support and support for all of PostgreSQL's special
operators:

* :class:`_postgresql.JSON`

* :class:`_postgresql.JSONB`

HSTORE Type
-----------

The PostgreSQL HSTORE type as well as hstore literals are supported:

* :class:`_postgresql.HSTORE` - HSTORE datatype

* :class:`_postgresql.hstore` - hstore literal

ENUM Types
----------

PostgreSQL has an independently creatable TYPE structure which is used
to implement an enumerated type.   This approach introduces significant
complexity on the SQLAlchemy side in terms of when this type should be
CREATED and DROPPED.   The type object is also an independently reflectable
entity.   The following sections should be consulted:

* :class:`_postgresql.ENUM` - DDL and typing support for ENUM.

* :meth:`.PGInspector.get_enums` - retrieve a listing of current ENUM types

* :meth:`.postgresql.ENUM.create` , :meth:`.postgresql.ENUM.drop` - individual
  CREATE and DROP commands for ENUM.

.. _postgresql_array_of_enum:

Using ENUM with ARRAY
^^^^^^^^^^^^^^^^^^^^^

The combination of ENUM and ARRAY is not directly supported by backend
DBAPIs at this time.   Prior to SQLAlchemy 1.3.17, a special workaround
was needed in order to allow this combination to work, described below.

.. versionchanged:: 1.3.17 The combination of ENUM and ARRAY is now directly
   handled by SQLAlchemy's implementation without any workarounds needed.

.. sourcecode:: python

    from sqlalchemy import TypeDecorator
    from sqlalchemy.dialects.postgresql import ARRAY

    class ArrayOfEnum(TypeDecorator):
        impl = ARRAY

        def bind_expression(self, bindvalue):
            return sa.cast(bindvalue, self)

        def result_processor(self, dialect, coltype):
            super_rp = super(ArrayOfEnum, self).result_processor(
                dialect, coltype)

            def handle_raw_string(value):
                inner = re.match(r"^{(.*)}$", value).group(1)
                return inner.split(",") if inner else []

            def process(value):
                if value is None:
                    return None
                return super_rp(handle_raw_string(value))
            return process

E.g.::

    Table(
        'mydata', metadata,
        Column('id', Integer, primary_key=True),
        Column('data', ArrayOfEnum(ENUM('a', 'b, 'c', name='myenum')))

    )

This type is not included as a built-in type as it would be incompatible
with a DBAPI that suddenly decides to support ARRAY of ENUM directly in
a new version.

.. _postgresql_array_of_json:

Using JSON/JSONB with ARRAY
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Similar to using ENUM, prior to SQLAlchemy 1.3.17, for an ARRAY of JSON/JSONB
we need to render the appropriate CAST.   Current psycopg2 drivers accomodate
the result set correctly without any special steps.

.. versionchanged:: 1.3.17 The combination of JSON/JSONB and ARRAY is now
   directly handled by SQLAlchemy's implementation without any workarounds
   needed.

.. sourcecode:: python

    class CastingArray(ARRAY):
        def bind_expression(self, bindvalue):
            return sa.cast(bindvalue, self)

E.g.::

    Table(
        'mydata', metadata,
        Column('id', Integer, primary_key=True),
        Column('data', CastingArray(JSONB))
    )


"""
IDX_USING = re.compile(r"^(?:btree|hash|gist|gin|[\w_]+)$", re.I)
AUTOCOMMIT_REGEXP = re.compile(r"\s*(?:UPDATE|INSERT|CREATE|DELETE|DROP|ALTER|GRANT|REVOKE|" "IMPORT FOREIGN SCHEMA|REFRESH MATERIALIZED VIEW|TRUNCATE)", re.I | re.UNICODE)
RESERVED_WORDS = set(["all", "analyse", "analyze", "and", "any", "array", "as", "asc", "asymmetric", "both", "case", "cast", "check", "collate", "column", "constraint", "create", "current_catalog", "current_date", "current_role", "current_time", "current_timestamp", "current_user", "default", "deferrable", "desc", "distinct", "do", "else", "end", "except", "false", "fetch", "for", "foreign", "from", "grant", "group", "having", "in", "initially", "intersect", "into", "leading", "limit", "localtime", "localtimestamp", "new", "not", "null", "of", "off", "offset", "old", "on", "only", "or", "order", "placing", "primary", "references", "returning", "select", "session_user", "some", "symmetric", "table", "then", "to", "trailing", "true", "union", "unique", "user", "using", "variadic", "when", "where", "window", "with", "authorization", "between", "binary", "cross", "current_schema", "freeze", "full", "ilike", "inner", "is", "isnull", "join", "left", "like", "natural", "notnull", "outer", "over", "overlaps", "right", "similar", "verbose"])
_DECIMAL_TYPES = (1231, 1700)
_FLOAT_TYPES = (700, 701, 1021, 1022)
_INT_TYPES = (20, 21, 23, 26, 1005, 1007, 1016)
class BYTEA(sqltypes.LargeBinary):
    __visit_name__ = ...


class DOUBLE_PRECISION(sqltypes.Float):
    __visit_name__ = ...


class INET(sqltypes.TypeEngine):
    __visit_name__ = ...


PGInet = INET
class CIDR(sqltypes.TypeEngine):
    __visit_name__ = ...


PGCidr = CIDR
class MACADDR(sqltypes.TypeEngine):
    __visit_name__ = ...


PGMacAddr = MACADDR
class MONEY(sqltypes.TypeEngine):
    """Provide the PostgreSQL MONEY type.

    .. versionadded:: 1.2

    """
    __visit_name__ = ...


class OID(sqltypes.TypeEngine):
    """Provide the PostgreSQL OID type.

    .. versionadded:: 0.9.5

    """
    __visit_name__ = ...


class REGCLASS(sqltypes.TypeEngine):
    """Provide the PostgreSQL REGCLASS type.

    .. versionadded:: 1.2.7

    """
    __visit_name__ = ...


class TIMESTAMP(sqltypes.TIMESTAMP):
    def __init__(self, timezone=..., precision=...) -> None:
        ...
    


class TIME(sqltypes.TIME):
    def __init__(self, timezone=..., precision=...) -> None:
        ...
    


class INTERVAL(sqltypes.NativeForEmulated, sqltypes._AbstractInterval):
    """PostgreSQL INTERVAL type.

    The INTERVAL type may not be supported on all DBAPIs.
    It is known to work on psycopg2 and not pg8000 or zxjdbc.

    """
    __visit_name__ = ...
    native = ...
    def __init__(self, precision=..., fields=...) -> None:
        """Construct an INTERVAL.

        :param precision: optional integer precision value
        :param fields: string fields specifier.  allows storage of fields
         to be limited, such as ``"YEAR"``, ``"MONTH"``, ``"DAY TO HOUR"``,
         etc.

         .. versionadded:: 1.2

        """
        ...
    
    @classmethod
    def adapt_emulated_to_native(cls, interval, **kw):
        ...
    
    @property
    def python_type(self):
        ...
    


PGInterval = INTERVAL
class BIT(sqltypes.TypeEngine):
    __visit_name__ = ...
    def __init__(self, length=..., varying=...) -> None:
        ...
    


PGBit = BIT
class UUID(sqltypes.TypeEngine):
    """PostgreSQL UUID type.

    Represents the UUID column type, interpreting
    data either as natively returned by the DBAPI
    or as Python uuid objects.

    The UUID type may not be supported on all DBAPIs.
    It is known to work on psycopg2 and not pg8000.

    """
    __visit_name__ = ...
    def __init__(self, as_uuid=...) -> None:
        """Construct a UUID type.


        :param as_uuid=False: if True, values will be interpreted
         as Python uuid objects, converting to/from string via the
         DBAPI.

        """
        ...
    
    def bind_processor(self, dialect):
        ...
    
    def result_processor(self, dialect, coltype):
        ...
    


PGUuid = UUID
class TSVECTOR(sqltypes.TypeEngine):
    """The :class:`_postgresql.TSVECTOR` type implements the PostgreSQL
    text search type TSVECTOR.

    It can be used to do full text queries on natural language
    documents.

    .. versionadded:: 0.9.0

    .. seealso::

        :ref:`postgresql_match`

    """
    __visit_name__ = ...


class ENUM(sqltypes.NativeForEmulated, sqltypes.Enum):
    """PostgreSQL ENUM type.

    This is a subclass of :class:`_types.Enum` which includes
    support for PG's ``CREATE TYPE`` and ``DROP TYPE``.

    When the builtin type :class:`_types.Enum` is used and the
    :paramref:`.Enum.native_enum` flag is left at its default of
    True, the PostgreSQL backend will use a :class:`_postgresql.ENUM`
    type as the implementation, so the special create/drop rules
    will be used.

    The create/drop behavior of ENUM is necessarily intricate, due to the
    awkward relationship the ENUM type has in relationship to the
    parent table, in that it may be "owned" by just a single table, or
    may be shared among many tables.

    When using :class:`_types.Enum` or :class:`_postgresql.ENUM`
    in an "inline" fashion, the ``CREATE TYPE`` and ``DROP TYPE`` is emitted
    corresponding to when the :meth:`_schema.Table.create` and
    :meth:`_schema.Table.drop`
    methods are called::

        table = Table('sometable', metadata,
            Column('some_enum', ENUM('a', 'b', 'c', name='myenum'))
        )

        table.create(engine)  # will emit CREATE ENUM and CREATE TABLE
        table.drop(engine)  # will emit DROP TABLE and DROP ENUM

    To use a common enumerated type between multiple tables, the best
    practice is to declare the :class:`_types.Enum` or
    :class:`_postgresql.ENUM` independently, and associate it with the
    :class:`_schema.MetaData` object itself::

        my_enum = ENUM('a', 'b', 'c', name='myenum', metadata=metadata)

        t1 = Table('sometable_one', metadata,
            Column('some_enum', myenum)
        )

        t2 = Table('sometable_two', metadata,
            Column('some_enum', myenum)
        )

    When this pattern is used, care must still be taken at the level
    of individual table creates.  Emitting CREATE TABLE without also
    specifying ``checkfirst=True`` will still cause issues::

        t1.create(engine) # will fail: no such type 'myenum'

    If we specify ``checkfirst=True``, the individual table-level create
    operation will check for the ``ENUM`` and create if not exists::

        # will check if enum exists, and emit CREATE TYPE if not
        t1.create(engine, checkfirst=True)

    When using a metadata-level ENUM type, the type will always be created
    and dropped if either the metadata-wide create/drop is called::

        metadata.create_all(engine)  # will emit CREATE TYPE
        metadata.drop_all(engine)  # will emit DROP TYPE

    The type can also be created and dropped directly::

        my_enum.create(engine)
        my_enum.drop(engine)

    .. versionchanged:: 1.0.0 The PostgreSQL :class:`_postgresql.ENUM` type
       now behaves more strictly with regards to CREATE/DROP.  A metadata-level
       ENUM type will only be created and dropped at the metadata level,
       not the table level, with the exception of
       ``table.create(checkfirst=True)``.
       The ``table.drop()`` call will now emit a DROP TYPE for a table-level
       enumerated type.

    """
    native_enum = ...
    def __init__(self, *enums, **kw) -> None:
        """Construct an :class:`_postgresql.ENUM`.

        Arguments are the same as that of
        :class:`_types.Enum`, but also including
        the following parameters.

        :param create_type: Defaults to True.
         Indicates that ``CREATE TYPE`` should be
         emitted, after optionally checking for the
         presence of the type, when the parent
         table is being created; and additionally
         that ``DROP TYPE`` is called when the table
         is dropped.    When ``False``, no check
         will be performed and no ``CREATE TYPE``
         or ``DROP TYPE`` is emitted, unless
         :meth:`~.postgresql.ENUM.create`
         or :meth:`~.postgresql.ENUM.drop`
         are called directly.
         Setting to ``False`` is helpful
         when invoking a creation scheme to a SQL file
         without access to the actual database -
         the :meth:`~.postgresql.ENUM.create` and
         :meth:`~.postgresql.ENUM.drop` methods can
         be used to emit SQL to a target bind.

        """
        ...
    
    @classmethod
    def adapt_emulated_to_native(cls, impl, **kw):
        """Produce a PostgreSQL native :class:`_postgresql.ENUM` from plain
        :class:`.Enum`.

        """
        ...
    
    def create(self, bind=..., checkfirst=...):
        """Emit ``CREATE TYPE`` for this
        :class:`_postgresql.ENUM`.

        If the underlying dialect does not support
        PostgreSQL CREATE TYPE, no action is taken.

        :param bind: a connectable :class:`_engine.Engine`,
         :class:`_engine.Connection`, or similar object to emit
         SQL.
        :param checkfirst: if ``True``, a query against
         the PG catalog will be first performed to see
         if the type does not exist already before
         creating.

        """
        ...
    
    def drop(self, bind=..., checkfirst=...):
        """Emit ``DROP TYPE`` for this
        :class:`_postgresql.ENUM`.

        If the underlying dialect does not support
        PostgreSQL DROP TYPE, no action is taken.

        :param bind: a connectable :class:`_engine.Engine`,
         :class:`_engine.Connection`, or similar object to emit
         SQL.
        :param checkfirst: if ``True``, a query against
         the PG catalog will be first performed to see
         if the type actually exists before dropping.

        """
        ...
    
    class EnumGenerator(DDLBase):
        def __init__(self, dialect, connection, checkfirst=..., **kwargs) -> None:
            ...
        
        def visit_enum(self, enum):
            ...
        
    
    
    class EnumDropper(DDLBase):
        def __init__(self, dialect, connection, checkfirst=..., **kwargs) -> None:
            ...
        
        def visit_enum(self, enum):
            ...
        
    
    


colspecs = { sqltypes.ARRAY: _array.ARRAY,sqltypes.Interval: INTERVAL,sqltypes.Enum: ENUM,sqltypes.JSON.JSONPathType: _json.JSONPathType,sqltypes.JSON: _json.JSON }
ischema_names = { "_array": _array.ARRAY,"hstore": _hstore.HSTORE,"json": _json.JSON,"jsonb": _json.JSONB,"int4range": _ranges.INT4RANGE,"int8range": _ranges.INT8RANGE,"numrange": _ranges.NUMRANGE,"daterange": _ranges.DATERANGE,"tsrange": _ranges.TSRANGE,"tstzrange": _ranges.TSTZRANGE,"integer": INTEGER,"bigint": BIGINT,"smallint": SMALLINT,"character varying": VARCHAR,"character": CHAR,'"char"': sqltypes.String,"name": sqltypes.String,"text": TEXT,"numeric": NUMERIC,"float": FLOAT,"real": REAL,"inet": INET,"cidr": CIDR,"uuid": UUID,"bit": BIT,"bit varying": BIT,"macaddr": MACADDR,"money": MONEY,"oid": OID,"regclass": REGCLASS,"double precision": DOUBLE_PRECISION,"timestamp": TIMESTAMP,"timestamp with time zone": TIMESTAMP,"timestamp without time zone": TIMESTAMP,"time with time zone": TIME,"time without time zone": TIME,"date": DATE,"time": TIME,"bytea": BYTEA,"boolean": BOOLEAN,"interval": INTERVAL,"tsvector": TSVECTOR }
class PGCompiler(compiler.SQLCompiler):
    def visit_array(self, element, **kw):
        ...
    
    def visit_slice(self, element, **kw):
        ...
    
    def visit_json_getitem_op_binary(self, binary, operator, _cast_applied=..., **kw):
        ...
    
    def visit_json_path_getitem_op_binary(self, binary, operator, _cast_applied=..., **kw):
        ...
    
    def visit_getitem_binary(self, binary, operator, **kw):
        ...
    
    def visit_aggregate_order_by(self, element, **kw):
        ...
    
    def visit_match_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_ilike_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_notilike_op_binary(self, binary, operator, **kw):
        ...
    
    def visit_empty_set_expr(self, element_types):
        ...
    
    def render_literal_value(self, value, type_):
        ...
    
    def visit_sequence(self, seq, **kw):
        ...
    
    def limit_clause(self, select, **kw):
        ...
    
    def format_from_hint_text(self, sqltext, table, hint, iscrud):
        ...
    
    def get_select_precolumns(self, select, **kw):
        ...
    
    def for_update_clause(self, select, **kw):
        ...
    
    def returning_clause(self, stmt, returning_cols):
        ...
    
    def visit_substring_func(self, func, **kw):
        ...
    
    def visit_on_conflict_do_nothing(self, on_conflict, **kw):
        ...
    
    def visit_on_conflict_do_update(self, on_conflict, **kw):
        ...
    
    def update_from_clause(self, update_stmt, from_table, extra_froms, from_hints, **kw):
        ...
    
    def delete_extra_from_clause(self, delete_stmt, from_table, extra_froms, from_hints, **kw):
        """Render the DELETE .. USING clause specific to PostgreSQL."""
        ...
    


class PGDDLCompiler(compiler.DDLCompiler):
    def get_column_specification(self, column, **kwargs):
        ...
    
    def visit_check_constraint(self, constraint):
        ...
    
    def visit_drop_table_comment(self, drop):
        ...
    
    def visit_create_enum_type(self, create):
        ...
    
    def visit_drop_enum_type(self, drop):
        ...
    
    def visit_create_index(self, create):
        ...
    
    def visit_drop_index(self, drop):
        ...
    
    def visit_exclude_constraint(self, constraint, **kw):
        ...
    
    def post_create_table(self, table):
        ...
    
    def visit_computed_column(self, generated):
        ...
    


class PGTypeCompiler(compiler.GenericTypeCompiler):
    def visit_TSVECTOR(self, type_, **kw):
        ...
    
    def visit_INET(self, type_, **kw):
        ...
    
    def visit_CIDR(self, type_, **kw):
        ...
    
    def visit_MACADDR(self, type_, **kw):
        ...
    
    def visit_MONEY(self, type_, **kw):
        ...
    
    def visit_OID(self, type_, **kw):
        ...
    
    def visit_REGCLASS(self, type_, **kw):
        ...
    
    def visit_FLOAT(self, type_, **kw):
        ...
    
    def visit_DOUBLE_PRECISION(self, type_, **kw):
        ...
    
    def visit_BIGINT(self, type_, **kw):
        ...
    
    def visit_HSTORE(self, type_, **kw):
        ...
    
    def visit_JSON(self, type_, **kw):
        ...
    
    def visit_JSONB(self, type_, **kw):
        ...
    
    def visit_INT4RANGE(self, type_, **kw):
        ...
    
    def visit_INT8RANGE(self, type_, **kw):
        ...
    
    def visit_NUMRANGE(self, type_, **kw):
        ...
    
    def visit_DATERANGE(self, type_, **kw):
        ...
    
    def visit_TSRANGE(self, type_, **kw):
        ...
    
    def visit_TSTZRANGE(self, type_, **kw):
        ...
    
    def visit_datetime(self, type_, **kw):
        ...
    
    def visit_enum(self, type_, **kw):
        ...
    
    def visit_ENUM(self, type_, identifier_preparer=..., **kw):
        ...
    
    def visit_TIMESTAMP(self, type_, **kw):
        ...
    
    def visit_TIME(self, type_, **kw):
        ...
    
    def visit_INTERVAL(self, type_, **kw):
        ...
    
    def visit_BIT(self, type_, **kw):
        ...
    
    def visit_UUID(self, type_, **kw):
        ...
    
    def visit_large_binary(self, type_, **kw):
        ...
    
    def visit_BYTEA(self, type_, **kw):
        ...
    
    def visit_ARRAY(self, type_, **kw):
        ...
    


class PGIdentifierPreparer(compiler.IdentifierPreparer):
    reserved_words = ...
    def format_type(self, type_, use_schema=...):
        ...
    


class PGInspector(reflection.Inspector):
    def __init__(self, conn) -> None:
        ...
    
    def get_table_oid(self, table_name, schema=...):
        """Return the OID for the given table name."""
        ...
    
    def get_enums(self, schema=...):
        """Return a list of ENUM objects.

        Each member is a dictionary containing these fields:

            * name - name of the enum
            * schema - the schema name for the enum.
            * visible - boolean, whether or not this enum is visible
              in the default search path.
            * labels - a list of string labels that apply to the enum.

        :param schema: schema name.  If None, the default schema
         (typically 'public') is used.  May also be set to '*' to
         indicate load enums for all schemas.

        .. versionadded:: 1.0.0

        """
        ...
    
    def get_foreign_table_names(self, schema=...):
        """Return a list of FOREIGN TABLE names.

        Behavior is similar to that of
        :meth:`_reflection.Inspector.get_table_names`,
        except that the list is limited to those tables that report a
        ``relkind`` value of ``f``.

        .. versionadded:: 1.0.0

        """
        ...
    
    def get_view_names(self, schema=..., include=...):
        """Return all view names in `schema`.

        :param schema: Optional, retrieve names from a non-default schema.
         For special quoting, use :class:`.quoted_name`.

        :param include: specify which types of views to return.  Passed
         as a string value (for a single type) or a tuple (for any number
         of types).  Defaults to ``('plain', 'materialized')``.

         .. versionadded:: 1.1

        """
        ...
    


class CreateEnumType(schema._CreateDropBase):
    __visit_name__ = ...


class DropEnumType(schema._CreateDropBase):
    __visit_name__ = ...


class PGExecutionContext(default.DefaultExecutionContext):
    def fire_sequence(self, seq, type_):
        ...
    
    def get_insert_default(self, column):
        ...
    
    def should_autocommit_text(self, statement):
        ...
    


class PGDialect(default.DefaultDialect):
    name = ...
    supports_alter = ...
    max_identifier_length = ...
    supports_sane_rowcount = ...
    supports_native_enum = ...
    supports_native_boolean = ...
    supports_smallserial = ...
    supports_sequences = ...
    sequences_optional = ...
    preexecute_autoincrement_sequences = ...
    postfetch_lastrowid = ...
    supports_comments = ...
    supports_default_values = ...
    supports_empty_insert = ...
    supports_multivalues_insert = ...
    default_paramstyle = ...
    ischema_names = ...
    colspecs = ...
    statement_compiler = ...
    ddl_compiler = ...
    type_compiler = ...
    preparer = ...
    execution_ctx_cls = ...
    inspector = ...
    isolation_level = ...
    construct_arguments = ...
    reflection_options = ...
    _backslash_escapes = ...
    _supports_create_index_concurrently = ...
    _supports_drop_index_concurrently = ...
    def __init__(self, isolation_level=..., json_serializer=..., json_deserializer=..., **kwargs) -> None:
        ...
    
    def initialize(self, connection):
        ...
    
    def on_connect(self):
        ...
    
    _isolation_lookup = ...
    def set_isolation_level(self, connection, level):
        ...
    
    def get_isolation_level(self, connection):
        ...
    
    def do_begin_twophase(self, connection, xid):
        ...
    
    def do_prepare_twophase(self, connection, xid):
        ...
    
    def do_rollback_twophase(self, connection, xid, is_prepared=..., recover=...):
        ...
    
    def do_commit_twophase(self, connection, xid, is_prepared=..., recover=...):
        ...
    
    def do_recover_twophase(self, connection):
        ...
    
    def has_schema(self, connection, schema):
        ...
    
    def has_table(self, connection, table_name, schema=...):
        ...
    
    def has_sequence(self, connection, sequence_name, schema=...):
        ...
    
    def has_type(self, connection, type_name, schema=...):
        ...
    
    @reflection.cache
    def get_table_oid(self, connection, table_name, schema=..., **kw):
        """Fetch the oid for schema.table_name.

        Several reflection methods require the table oid.  The idea for using
        this method is that it can be fetched one time and cached for
        subsequent calls.

        """
        ...
    
    @reflection.cache
    def get_schema_names(self, connection, **kw):
        ...
    
    @reflection.cache
    def get_table_names(self, connection, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_view_names(self, connection, schema=..., include=..., **kw):
        ...
    
    @reflection.cache
    def get_view_definition(self, connection, view_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_columns(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_pk_constraint(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_foreign_keys(self, connection, table_name, schema=..., postgresql_ignore_search_path=..., **kw):
        ...
    
    @reflection.cache
    def get_indexes(self, connection, table_name, schema, **kw):
        ...
    
    @reflection.cache
    def get_unique_constraints(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_table_comment(self, connection, table_name, schema=..., **kw):
        ...
    
    @reflection.cache
    def get_check_constraints(self, connection, table_name, schema=..., **kw):
        ...
    


