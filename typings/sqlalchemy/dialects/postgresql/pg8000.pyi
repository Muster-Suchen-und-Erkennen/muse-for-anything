"""
This type stub file was generated by pyright.
"""

from .base import PGCompiler, PGDialect, PGExecutionContext, PGIdentifierPreparer, UUID
from .json import JSON
from ... import types as sqltypes

r"""
.. dialect:: postgresql+pg8000
    :name: pg8000
    :dbapi: pg8000
    :connectstring: postgresql+pg8000://user:password@host:port/dbname[?key=value&key=value...]
    :url: https://pythonhosted.org/pg8000/

.. note::

    The pg8000 dialect is **not tested as part of SQLAlchemy's continuous
    integration** and may have unresolved issues.  The recommended PostgreSQL
    dialect is psycopg2.

.. _pg8000_unicode:

Unicode
-------

pg8000 will encode / decode string values between it and the server using the
PostgreSQL ``client_encoding`` parameter; by default this is the value in
the ``postgresql.conf`` file, which often defaults to ``SQL_ASCII``.
Typically, this can be changed to ``utf-8``, as a more useful default::

    #client_encoding = sql_ascii # actually, defaults to database
                                 # encoding
    client_encoding = utf8

The ``client_encoding`` can be overridden for a session by executing the SQL:

SET CLIENT_ENCODING TO 'utf8';

SQLAlchemy will execute this SQL on all new connections based on the value
passed to :func:`_sa.create_engine` using the ``client_encoding`` parameter::

    engine = create_engine(
        "postgresql+pg8000://user:pass@host/dbname", client_encoding='utf8')


.. _pg8000_isolation_level:

pg8000 Transaction Isolation Level
-------------------------------------

The pg8000 dialect offers the same isolation level settings as that
of the :ref:`psycopg2 <psycopg2_isolation_level>` dialect:

* ``READ COMMITTED``
* ``READ UNCOMMITTED``
* ``REPEATABLE READ``
* ``SERIALIZABLE``
* ``AUTOCOMMIT``

.. versionadded:: 0.9.5 support for AUTOCOMMIT isolation level when using
   pg8000.

.. seealso::

    :ref:`postgresql_isolation_level`

    :ref:`psycopg2_isolation_level`


"""
class _PGNumeric(sqltypes.Numeric):
    def result_processor(self, dialect, coltype):
        ...
    


class _PGNumericNoBind(_PGNumeric):
    def bind_processor(self, dialect):
        ...
    


class _PGJSON(JSON):
    def result_processor(self, dialect, coltype):
        ...
    


class _PGUUID(UUID):
    def bind_processor(self, dialect):
        ...
    
    def result_processor(self, dialect, coltype):
        ...
    


class PGExecutionContext_pg8000(PGExecutionContext):
    ...


class PGCompiler_pg8000(PGCompiler):
    def visit_mod_binary(self, binary, operator, **kw):
        ...
    
    def post_process_text(self, text):
        ...
    


class PGIdentifierPreparer_pg8000(PGIdentifierPreparer):
    ...


class PGDialect_pg8000(PGDialect):
    driver = ...
    supports_unicode_statements = ...
    supports_unicode_binds = ...
    default_paramstyle = ...
    supports_sane_multi_rowcount = ...
    execution_ctx_cls = ...
    statement_compiler = ...
    preparer = ...
    description_encoding = ...
    colspecs = ...
    def __init__(self, client_encoding=..., **kwargs) -> None:
        ...
    
    def initialize(self, connection):
        ...
    
    @classmethod
    def dbapi(cls):
        ...
    
    def create_connect_args(self, url):
        ...
    
    def is_disconnect(self, e, connection, cursor):
        ...
    
    def set_isolation_level(self, connection, level):
        ...
    
    def set_client_encoding(self, connection, client_encoding):
        ...
    
    def do_begin_twophase(self, connection, xid):
        ...
    
    def do_prepare_twophase(self, connection, xid):
        ...
    
    def do_rollback_twophase(self, connection, xid, is_prepared=..., recover=...):
        ...
    
    def do_commit_twophase(self, connection, xid, is_prepared=..., recover=...):
        ...
    
    def do_recover_twophase(self, connection):
        ...
    
    def on_connect(self):
        ...
    


dialect = PGDialect_pg8000
