"""
This type stub file was generated by pyright.
"""

import re
from ... import types as sqltypes
from ...sql import functions as sqlfunc, operators

idx_precedence = operators._PRECEDENCE[operators.json_getitem_op]
GETITEM = operators.custom_op("->", precedence=idx_precedence, natural_self_precedent=True, eager_grouping=True)
HAS_KEY = operators.custom_op("?", precedence=idx_precedence, natural_self_precedent=True, eager_grouping=True)
HAS_ALL = operators.custom_op("?&", precedence=idx_precedence, natural_self_precedent=True, eager_grouping=True)
HAS_ANY = operators.custom_op("?|", precedence=idx_precedence, natural_self_precedent=True, eager_grouping=True)
CONTAINS = operators.custom_op("@>", precedence=idx_precedence, natural_self_precedent=True, eager_grouping=True)
CONTAINED_BY = operators.custom_op("<@", precedence=idx_precedence, natural_self_precedent=True, eager_grouping=True)
class HSTORE(sqltypes.Indexable, sqltypes.Concatenable, sqltypes.TypeEngine):
    """Represent the PostgreSQL HSTORE type.

    The :class:`.HSTORE` type stores dictionaries containing strings, e.g.::

        data_table = Table('data_table', metadata,
            Column('id', Integer, primary_key=True),
            Column('data', HSTORE)
        )

        with engine.connect() as conn:
            conn.execute(
                data_table.insert(),
                data = {"key1": "value1", "key2": "value2"}
            )

    :class:`.HSTORE` provides for a wide range of operations, including:

    * Index operations::

        data_table.c.data['some key'] == 'some value'

    * Containment operations::

        data_table.c.data.has_key('some key')

        data_table.c.data.has_all(['one', 'two', 'three'])

    * Concatenation::

        data_table.c.data + {"k1": "v1"}

    For a full list of special methods see
    :class:`.HSTORE.comparator_factory`.

    For usage with the SQLAlchemy ORM, it may be desirable to combine
    the usage of :class:`.HSTORE` with :class:`.MutableDict` dictionary
    now part of the :mod:`sqlalchemy.ext.mutable`
    extension.  This extension will allow "in-place" changes to the
    dictionary, e.g. addition of new keys or replacement/removal of existing
    keys to/from the current dictionary, to produce events which will be
    detected by the unit of work::

        from sqlalchemy.ext.mutable import MutableDict

        class MyClass(Base):
            __tablename__ = 'data_table'

            id = Column(Integer, primary_key=True)
            data = Column(MutableDict.as_mutable(HSTORE))

        my_object = session.query(MyClass).one()

        # in-place mutation, requires Mutable extension
        # in order for the ORM to detect
        my_object.data['some_key'] = 'some value'

        session.commit()

    When the :mod:`sqlalchemy.ext.mutable` extension is not used, the ORM
    will not be alerted to any changes to the contents of an existing
    dictionary, unless that dictionary value is re-assigned to the
    HSTORE-attribute itself, thus generating a change event.

    .. seealso::

        :class:`.hstore` - render the PostgreSQL ``hstore()`` function.


    """
    __visit_name__ = ...
    hashable = ...
    text_type = ...
    def __init__(self, text_type=...) -> None:
        """Construct a new :class:`.HSTORE`.

        :param text_type: the type that should be used for indexed values.
         Defaults to :class:`_types.Text`.

         .. versionadded:: 1.1.0

        """
        ...
    
    class Comparator(sqltypes.Indexable.Comparator, sqltypes.Concatenable.Comparator):
        """Define comparison operations for :class:`.HSTORE`."""
        def has_key(self, other):
            """Boolean expression.  Test for presence of a key.  Note that the
            key may be a SQLA expression.
            """
            ...
        
        def has_all(self, other):
            """Boolean expression.  Test for presence of all keys in jsonb"""
            ...
        
        def has_any(self, other):
            """Boolean expression.  Test for presence of any key in jsonb"""
            ...
        
        def contains(self, other, **kwargs):
            """Boolean expression.  Test if keys (or array) are a superset
            of/contained the keys of the argument jsonb expression.
            """
            ...
        
        def contained_by(self, other):
            """Boolean expression.  Test if keys are a proper subset of the
            keys of the argument jsonb expression.
            """
            ...
        
        def defined(self, key):
            """Boolean expression.  Test for presence of a non-NULL value for
            the key.  Note that the key may be a SQLA expression.
            """
            ...
        
        def delete(self, key):
            """HStore expression.  Returns the contents of this hstore with the
            given key deleted.  Note that the key may be a SQLA expression.
            """
            ...
        
        def slice(self, array):
            """HStore expression.  Returns a subset of an hstore defined by
            array of keys.
            """
            ...
        
        def keys(self):
            """Text array expression.  Returns array of keys."""
            ...
        
        def vals(self):
            """Text array expression.  Returns array of values."""
            ...
        
        def array(self):
            """Text array expression.  Returns array of alternating keys and
            values.
            """
            ...
        
        def matrix(self):
            """Text array expression.  Returns array of [key, value] pairs."""
            ...
        
    
    
    comparator_factory = ...
    def bind_processor(self, dialect):
        ...
    
    def result_processor(self, dialect, coltype):
        ...
    


class hstore(sqlfunc.GenericFunction):
    """Construct an hstore value within a SQL expression using the
    PostgreSQL ``hstore()`` function.

    The :class:`.hstore` function accepts one or two arguments as described
    in the PostgreSQL documentation.

    E.g.::

        from sqlalchemy.dialects.postgresql import array, hstore

        select([hstore('key1', 'value1')])

        select([
                hstore(
                    array(['key1', 'key2', 'key3']),
                    array(['value1', 'value2', 'value3'])
                )
            ])

    .. seealso::

        :class:`.HSTORE` - the PostgreSQL ``HSTORE`` datatype.

    """
    type = ...
    name = ...


class _HStoreDefinedFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


class _HStoreDeleteFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


class _HStoreSliceFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


class _HStoreKeysFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


class _HStoreValsFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


class _HStoreArrayFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


class _HStoreMatrixFunction(sqlfunc.GenericFunction):
    type = ...
    name = ...


HSTORE_PAIR_RE = re.compile(r"""
(
  "(?P<key> (\\ . | [^"])* )"       # Quoted key
)
[ ]* => [ ]*    # Pair operator, optional adjoining whitespace
(
    (?P<value_null> NULL )          # NULL value
  | "(?P<value> (\\ . | [^"])* )"   # Quoted value
)
""", re.VERBOSE)
HSTORE_DELIMITER_RE = re.compile(r"""
[ ]* , [ ]*
""", re.VERBOSE)
