"""
This type stub file was generated by pyright.
"""

from .annotation import Annotated
from .base import Executable, Generative, Immutable, _from_objects, _generative
from .elements import BindParameter, ClauseElement, Grouping, UnaryExpression, _document_text_coercion
from .. import util

"""The :class:`_expression.FromClause` class of SQL expression elements,
representing
SQL tables and derived rowsets.

"""
class _OffsetLimitParam(BindParameter):
    ...


def subquery(alias, *args, **kwargs):
    r"""Return an :class:`_expression.Alias` object derived
    from a :class:`_expression.Select`.

    :param alias: the alias name

    :param \*args, \**kwargs:  all other arguments are delivered to the
     :func:`_expression.select` function.

    """
    ...

class Selectable(ClauseElement):
    """Mark a class as being selectable."""
    __visit_name__ = ...
    is_selectable = ...
    @property
    def selectable(self):
        ...
    


class HasPrefixes(object):
    _prefixes = ...
    @_generative
    @_document_text_coercion("expr", ":meth:`_expression.HasPrefixes.prefix_with`", ":paramref:`.HasPrefixes.prefix_with.*expr`")
    def prefix_with(self, *expr, **kw):
        r"""Add one or more expressions following the statement keyword, i.e.
        SELECT, INSERT, UPDATE, or DELETE. Generative.

        This is used to support backend-specific prefix keywords such as those
        provided by MySQL.

        E.g.::

            stmt = table.insert().prefix_with("LOW_PRIORITY", dialect="mysql")

            # MySQL 5.7 optimizer hints
            stmt = select([table]).prefix_with(
                "/*+ BKA(t1) */", dialect="mysql")

        Multiple prefixes can be specified by multiple calls
        to :meth:`_expression.HasPrefixes.prefix_with`.

        :param \*expr: textual or :class:`_expression.ClauseElement`
         construct which
         will be rendered following the INSERT, UPDATE, or DELETE
         keyword.
        :param \**kw: A single keyword 'dialect' is accepted.  This is an
         optional string dialect name which will
         limit rendering of this prefix to only that dialect.

        """
        ...
    


class HasSuffixes(object):
    _suffixes = ...
    @_generative
    @_document_text_coercion("expr", ":meth:`_expression.HasSuffixes.suffix_with`", ":paramref:`.HasSuffixes.suffix_with.*expr`")
    def suffix_with(self, *expr, **kw):
        r"""Add one or more expressions following the statement as a whole.

        This is used to support backend-specific suffix keywords on
        certain constructs.

        E.g.::

            stmt = select([col1, col2]).cte().suffix_with(
                "cycle empno set y_cycle to 1 default 0", dialect="oracle")

        Multiple suffixes can be specified by multiple calls
        to :meth:`_expression.HasSuffixes.suffix_with`.

        :param \*expr: textual or :class:`_expression.ClauseElement`
         construct which
         will be rendered following the target clause.
        :param \**kw: A single keyword 'dialect' is accepted.  This is an
         optional string dialect name which will
         limit rendering of this suffix to only that dialect.

        """
        ...
    


class FromClause(Selectable):
    """Represent an element that can be used within the ``FROM``
    clause of a ``SELECT`` statement.

    The most common forms of :class:`_expression.FromClause` are the
    :class:`_schema.Table` and the :func:`_expression.select` constructs.  Key
    features common to all :class:`_expression.FromClause` objects include:

    * a :attr:`.c` collection, which provides per-name access to a collection
      of :class:`_expression.ColumnElement` objects.
    * a :attr:`.primary_key` attribute, which is a collection of all those
      :class:`_expression.ColumnElement`
      objects that indicate the ``primary_key`` flag.
    * Methods to generate various derivations of a "from" clause, including
      :meth:`_expression.FromClause.alias`,
      :meth:`_expression.FromClause.join`,
      :meth:`_expression.FromClause.select`.


    """
    __visit_name__ = ...
    named_with_column = ...
    _hide_froms = ...
    _is_join = ...
    _is_select = ...
    _is_from_container = ...
    _is_lateral = ...
    _textual = ...
    schema = ...
    _memoized_property = ...
    @util.deprecated("1.1", message="The :meth:`.FromClause.count` method is deprecated, " "and will be removed in a future release.   Please use the " ":class:`_functions.count` function available from the " ":attr:`.func` namespace.")
    @util.dependencies("sqlalchemy.sql.functions")
    def count(self, functions, whereclause=..., **params):
        """Return a SELECT COUNT generated against this
        :class:`_expression.FromClause`.

        .. seealso::

            :class:`_functions.count`

        """
        ...
    
    def select(self, whereclause=..., **params):
        """Return a SELECT of this :class:`_expression.FromClause`.

        .. seealso::

            :func:`_expression.select` - general purpose
            method which allows for arbitrary column lists.

        """
        ...
    
    def join(self, right, onclause=..., isouter=..., full=...):
        """Return a :class:`_expression.Join` from this
        :class:`_expression.FromClause` to another
        :class:`_expression.FromClause`.

        E.g.::

            from sqlalchemy import join

            j = user_table.join(address_table,
                            user_table.c.id == address_table.c.user_id)
            stmt = select([user_table]).select_from(j)

        would emit SQL along the lines of::

            SELECT user.id, user.name FROM user
            JOIN address ON user.id = address.user_id

        :param right: the right side of the join; this is any
         :class:`_expression.FromClause` object such as a
         :class:`_schema.Table` object, and
         may also be a selectable-compatible object such as an ORM-mapped
         class.

        :param onclause: a SQL expression representing the ON clause of the
         join.  If left at ``None``, :meth:`_expression.FromClause.join`
         will attempt to
         join the two tables based on a foreign key relationship.

        :param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN.

        :param full: if True, render a FULL OUTER JOIN, instead of LEFT OUTER
         JOIN.  Implies :paramref:`.FromClause.join.isouter`.

         .. versionadded:: 1.1

        .. seealso::

            :func:`_expression.join` - standalone function

            :class:`_expression.Join` - the type of object produced

        """
        ...
    
    def outerjoin(self, right, onclause=..., full=...):
        """Return a :class:`_expression.Join` from this
        :class:`_expression.FromClause`
        to another :class:`FromClause`, with the "isouter" flag set to
        True.

        E.g.::

            from sqlalchemy import outerjoin

            j = user_table.outerjoin(address_table,
                            user_table.c.id == address_table.c.user_id)

        The above is equivalent to::

            j = user_table.join(
                address_table,
                user_table.c.id == address_table.c.user_id,
                isouter=True)

        :param right: the right side of the join; this is any
         :class:`_expression.FromClause` object such as a
         :class:`_schema.Table` object, and
         may also be a selectable-compatible object such as an ORM-mapped
         class.

        :param onclause: a SQL expression representing the ON clause of the
         join.  If left at ``None``, :meth:`_expression.FromClause.join`
         will attempt to
         join the two tables based on a foreign key relationship.

        :param full: if True, render a FULL OUTER JOIN, instead of
         LEFT OUTER JOIN.

         .. versionadded:: 1.1

        .. seealso::

            :meth:`_expression.FromClause.join`

            :class:`_expression.Join`

        """
        ...
    
    def alias(self, name=..., flat=...):
        """Return an alias of this :class:`_expression.FromClause`.

        E.g.::

            a2 = some_table.alias('a2')

        The above code creates an :class:`_expression.Alias`
        object which can be used
        as a FROM clause in any SELECT statement.

        .. seealso::

            :ref:`core_tutorial_aliases`

            :func:`_expression.alias`

        """
        ...
    
    def lateral(self, name=...):
        """Return a LATERAL alias of this :class:`_expression.FromClause`.

        The return value is the :class:`_expression.Lateral` construct also
        provided by the top-level :func:`_expression.lateral` function.

        .. versionadded:: 1.1

        .. seealso::

            :ref:`lateral_selects` -  overview of usage.

        """
        ...
    
    def tablesample(self, sampling, name=..., seed=...):
        """Return a TABLESAMPLE alias of this :class:`_expression.FromClause`.

        The return value is the :class:`_expression.TableSample`
        construct also
        provided by the top-level :func:`_expression.tablesample` function.

        .. versionadded:: 1.1

        .. seealso::

            :func:`_expression.tablesample` - usage guidelines and parameters

        """
        ...
    
    def is_derived_from(self, fromclause):
        """Return ``True`` if this :class:`_expression.FromClause` is
        'derived' from the given ``FromClause``.

        An example would be an Alias of a Table is derived from that Table.

        """
        ...
    
    @util.dependencies("sqlalchemy.sql.util")
    def replace_selectable(self, sqlutil, old, alias):
        """Replace all occurrences of FromClause 'old' with the given Alias
        object, returning a copy of this :class:`_expression.FromClause`.

        """
        ...
    
    def correspond_on_equivalents(self, column, equivalents):
        """Return corresponding_column for the given column, or if None
        search for a match in the given dictionary.

        """
        ...
    
    def corresponding_column(self, column, require_embedded=...):
        """Given a :class:`_expression.ColumnElement`, return the exported
        :class:`_expression.ColumnElement` object from this
        :class:`expression.Selectable`
        which corresponds to that original
        :class:`~sqlalchemy.schema.Column` via a common ancestor
        column.

        :param column: the target :class:`_expression.ColumnElement`
                      to be matched

        :param require_embedded: only return corresponding columns for
         the given :class:`_expression.ColumnElement`, if the given
         :class:`_expression.ColumnElement`
         is actually present within a sub-element
         of this :class:`_expression.FromClause`.
         Normally the column will match if
         it merely shares a common ancestor with one of the exported
         columns of this :class:`_expression.FromClause`.

        """
        ...
    
    @property
    def description(self):
        """A brief description of this :class:`_expression.FromClause`.

        Used primarily for error message formatting.

        """
        ...
    
    @_memoized_property
    def columns(self):
        """A named-based collection of :class:`_expression.ColumnElement`
        objects
        maintained by this :class:`_expression.FromClause`.

        The :attr:`.columns`, or :attr:`.c` collection, is the gateway
        to the construction of SQL expressions using table-bound or
        other selectable-bound columns::

            select([mytable]).where(mytable.c.somecolumn == 5)

        """
        ...
    
    @_memoized_property
    def primary_key(self):
        """Return the collection of :class:`_schema.Column` objects
        which comprise the primary key of this FromClause.

        """
        ...
    
    @_memoized_property
    def foreign_keys(self):
        """Return the collection of :class:`_schema.ForeignKey` objects
        which this FromClause references.

        """
        ...
    
    c = ...
    _select_iterable = ...


class Join(FromClause):
    """Represent a ``JOIN`` construct between two
    :class:`_expression.FromClause` elements.

    The public constructor function for :class:`_expression.Join`
    is the module-level
    :func:`_expression.join()` function, as well as the
    :meth:`_expression.FromClause.join` method
    of any :class:`_expression.FromClause` (e.g. such as
    :class:`_schema.Table`).

    .. seealso::

        :func:`_expression.join`

        :meth:`_expression.FromClause.join`

    """
    __visit_name__ = ...
    _is_join = ...
    def __init__(self, left, right, onclause=..., isouter=..., full=...) -> None:
        """Construct a new :class:`_expression.Join`.

        The usual entrypoint here is the :func:`_expression.join`
        function or the :meth:`_expression.FromClause.join` method of any
        :class:`_expression.FromClause` object.

        """
        ...
    
    @property
    def description(self):
        ...
    
    def is_derived_from(self, fromclause):
        ...
    
    def self_group(self, against=...):
        ...
    
    def get_children(self, **kwargs):
        ...
    
    def select(self, whereclause=..., **kwargs):
        r"""Create a :class:`_expression.Select` from this
        :class:`_expression.Join`.

        The equivalent long-hand form, given a :class:`_expression.Join`
        object
        ``j``, is::

            from sqlalchemy import select
            j = select([j.left, j.right], **kw).\
                        where(whereclause).\
                        select_from(j)

        :param whereclause: the WHERE criterion that will be sent to
          the :func:`select()` function

        :param \**kwargs: all other kwargs are sent to the
          underlying :func:`select()` function.

        """
        ...
    
    @property
    def bind(self):
        ...
    
    @util.dependencies("sqlalchemy.sql.util")
    def alias(self, sqlutil, name=..., flat=...):
        r"""Return an alias of this :class:`_expression.Join`.

        The default behavior here is to first produce a SELECT
        construct from this :class:`_expression.Join`, then to produce an
        :class:`_expression.Alias` from that.  So given a join of the form::

            j = table_a.join(table_b, table_a.c.id == table_b.c.a_id)

        The JOIN by itself would look like::

            table_a JOIN table_b ON table_a.id = table_b.a_id

        Whereas the alias of the above, ``j.alias()``, would in a
        SELECT context look like::

            (SELECT table_a.id AS table_a_id, table_b.id AS table_b_id,
                table_b.a_id AS table_b_a_id
                FROM table_a
                JOIN table_b ON table_a.id = table_b.a_id) AS anon_1

        The equivalent long-hand form, given a :class:`_expression.Join`
        object
        ``j``, is::

            from sqlalchemy import select, alias
            j = alias(
                select([j.left, j.right]).\
                    select_from(j).\
                    with_labels(True).\
                    correlate(False),
                name=name
            )

        The selectable produced by :meth:`_expression.Join.alias`
        features the same
        columns as that of the two individual selectables presented under
        a single name - the individual columns are "auto-labeled", meaning
        the ``.c.`` collection of the resulting :class:`_expression.Alias`
        represents
        the names of the individual columns using a
        ``<tablename>_<columname>`` scheme::

            j.c.table_a_id
            j.c.table_b_a_id

        :meth:`_expression.Join.alias` also features an alternate
        option for aliasing joins which produces no enclosing SELECT and
        does not normally apply labels to the column names.  The
        ``flat=True`` option will call :meth:`_expression.FromClause.alias`
        against the left and right sides individually.
        Using this option, no new ``SELECT`` is produced;
        we instead, from a construct as below::

            j = table_a.join(table_b, table_a.c.id == table_b.c.a_id)
            j = j.alias(flat=True)

        we get a result like this::

            table_a AS table_a_1 JOIN table_b AS table_b_1 ON
            table_a_1.id = table_b_1.a_id

        The ``flat=True`` argument is also propagated to the contained
        selectables, so that a composite join such as::

            j = table_a.join(
                    table_b.join(table_c,
                            table_b.c.id == table_c.c.b_id),
                    table_b.c.a_id == table_a.c.id
                ).alias(flat=True)

        Will produce an expression like::

            table_a AS table_a_1 JOIN (
                    table_b AS table_b_1 JOIN table_c AS table_c_1
                    ON table_b_1.id = table_c_1.b_id
            ) ON table_a_1.id = table_b_1.a_id

        The standalone :func:`_expression.alias` function as well as the
        base :meth:`_expression.FromClause.alias`
        method also support the ``flat=True``
        argument as a no-op, so that the argument can be passed to the
        ``alias()`` method of any selectable.

        .. versionadded:: 0.9.0 Added the ``flat=True`` option to create
          "aliases" of joins without enclosing inside of a SELECT
          subquery.

        :param name: name given to the alias.

        :param flat: if True, produce an alias of the left and right
         sides of this :class:`_expression.Join` and return the join of those
         two selectables.   This produces join expression that does not
         include an enclosing SELECT.

         .. versionadded:: 0.9.0

        .. seealso::

            :ref:`core_tutorial_aliases`

            :func:`_expression.alias`

        """
        ...
    


class Alias(FromClause):
    """Represents an table or selectable alias (AS).

    Represents an alias, as typically applied to any table or
    sub-select within a SQL statement using the ``AS`` keyword (or
    without the keyword on certain databases such as Oracle).

    This object is constructed from the :func:`_expression.alias` module
    level function as well as the :meth:`_expression.FromClause.alias`
    method available
    on all :class:`_expression.FromClause` subclasses.

    """
    __visit_name__ = ...
    named_with_column = ...
    _is_from_container = ...
    def __init__(self, *arg, **kw) -> None:
        ...
    
    def self_group(self, against=...):
        ...
    
    @property
    def description(self):
        ...
    
    def as_scalar(self):
        ...
    
    def is_derived_from(self, fromclause):
        ...
    
    def get_children(self, column_collections=..., **kw):
        ...
    
    @property
    def bind(self):
        ...
    


class Lateral(Alias):
    """Represent a LATERAL subquery.

    This object is constructed from the :func:`_expression.lateral` module
    level function as well as the :meth:`_expression.FromClause.lateral`
    method available
    on all :class:`_expression.FromClause` subclasses.

    While LATERAL is part of the SQL standard, currently only more recent
    PostgreSQL versions provide support for this keyword.

    .. versionadded:: 1.1

    .. seealso::

        :ref:`lateral_selects` -  overview of usage.

    """
    __visit_name__ = ...
    _is_lateral = ...


class TableSample(Alias):
    """Represent a TABLESAMPLE clause.

    This object is constructed from the :func:`_expression.tablesample` module
    level function as well as the :meth:`_expression.FromClause.tablesample`
    method
    available on all :class:`_expression.FromClause` subclasses.

    .. versionadded:: 1.1

    .. seealso::

        :func:`_expression.tablesample`

    """
    __visit_name__ = ...


class CTE(Generative, HasPrefixes, HasSuffixes, Alias):
    """Represent a Common Table Expression.

    The :class:`_expression.CTE` object is obtained using the
    :meth:`_expression.SelectBase.cte` method from any selectable.
    See that method for complete examples.

    """
    __visit_name__ = ...
    def alias(self, name=..., flat=...):
        """Return an :class:`_expression.Alias` of this
        :class:`_expression.CTE`.

        This method is a CTE-specific specialization of the
        :meth:`_expression.FromClause.alias` method.

        .. seealso::

            :ref:`core_tutorial_aliases`

            :func:`_expression.alias`

        """
        ...
    
    def union(self, other):
        ...
    
    def union_all(self, other):
        ...
    


class HasCTE(object):
    """Mixin that declares a class to include CTE support.

    .. versionadded:: 1.1

    """
    def cte(self, name=..., recursive=...):
        r"""Return a new :class:`_expression.CTE`,
        or Common Table Expression instance.

        Common table expressions are a SQL standard whereby SELECT
        statements can draw upon secondary statements specified along
        with the primary statement, using a clause called "WITH".
        Special semantics regarding UNION can also be employed to
        allow "recursive" queries, where a SELECT statement can draw
        upon the set of rows that have previously been selected.

        CTEs can also be applied to DML constructs UPDATE, INSERT
        and DELETE on some databases, both as a source of CTE rows
        when combined with RETURNING, as well as a consumer of
        CTE rows.

        .. versionchanged:: 1.1 Added support for UPDATE/INSERT/DELETE as
           CTE, CTEs added to UPDATE/INSERT/DELETE.

        SQLAlchemy detects :class:`_expression.CTE` objects, which are treated
        similarly to :class:`_expression.Alias` objects, as special elements
        to be delivered to the FROM clause of the statement as well
        as to a WITH clause at the top of the statement.

        For special prefixes such as PostgreSQL "MATERIALIZED" and
        "NOT MATERIALIZED", the :meth:`_expression.CTE.prefix_with`
        method may be
        used to establish these.

        .. versionchanged:: 1.3.13 Added support for prefixes.
           In particular - MATERIALIZED and NOT MATERIALIZED.

        :param name: name given to the common table expression.  Like
         :meth:`_expression.FromClause.alias`, the name can be left as
         ``None`` in which case an anonymous symbol will be used at query
         compile time.
        :param recursive: if ``True``, will render ``WITH RECURSIVE``.
         A recursive common table expression is intended to be used in
         conjunction with UNION ALL in order to derive rows
         from those already selected.

        The following examples include two from PostgreSQL's documentation at
        http://www.postgresql.org/docs/current/static/queries-with.html,
        as well as additional examples.

        Example 1, non recursive::

            from sqlalchemy import (Table, Column, String, Integer,
                                    MetaData, select, func)

            metadata = MetaData()

            orders = Table('orders', metadata,
                Column('region', String),
                Column('amount', Integer),
                Column('product', String),
                Column('quantity', Integer)
            )

            regional_sales = select([
                                orders.c.region,
                                func.sum(orders.c.amount).label('total_sales')
                            ]).group_by(orders.c.region).cte("regional_sales")


            top_regions = select([regional_sales.c.region]).\
                    where(
                        regional_sales.c.total_sales >
                        select([
                            func.sum(regional_sales.c.total_sales)/10
                        ])
                    ).cte("top_regions")

            statement = select([
                        orders.c.region,
                        orders.c.product,
                        func.sum(orders.c.quantity).label("product_units"),
                        func.sum(orders.c.amount).label("product_sales")
                ]).where(orders.c.region.in_(
                    select([top_regions.c.region])
                )).group_by(orders.c.region, orders.c.product)

            result = conn.execute(statement).fetchall()

        Example 2, WITH RECURSIVE::

            from sqlalchemy import (Table, Column, String, Integer,
                                    MetaData, select, func)

            metadata = MetaData()

            parts = Table('parts', metadata,
                Column('part', String),
                Column('sub_part', String),
                Column('quantity', Integer),
            )

            included_parts = select([
                                parts.c.sub_part,
                                parts.c.part,
                                parts.c.quantity]).\
                                where(parts.c.part=='our part').\
                                cte(recursive=True)


            incl_alias = included_parts.alias()
            parts_alias = parts.alias()
            included_parts = included_parts.union_all(
                select([
                    parts_alias.c.sub_part,
                    parts_alias.c.part,
                    parts_alias.c.quantity
                ]).
                    where(parts_alias.c.part==incl_alias.c.sub_part)
            )

            statement = select([
                        included_parts.c.sub_part,
                        func.sum(included_parts.c.quantity).
                          label('total_quantity')
                    ]).\
                    group_by(included_parts.c.sub_part)

            result = conn.execute(statement).fetchall()

        Example 3, an upsert using UPDATE and INSERT with CTEs::

            from datetime import date
            from sqlalchemy import (MetaData, Table, Column, Integer,
                                    Date, select, literal, and_, exists)

            metadata = MetaData()

            visitors = Table('visitors', metadata,
                Column('product_id', Integer, primary_key=True),
                Column('date', Date, primary_key=True),
                Column('count', Integer),
            )

            # add 5 visitors for the product_id == 1
            product_id = 1
            day = date.today()
            count = 5

            update_cte = (
                visitors.update()
                .where(and_(visitors.c.product_id == product_id,
                            visitors.c.date == day))
                .values(count=visitors.c.count + count)
                .returning(literal(1))
                .cte('update_cte')
            )

            upsert = visitors.insert().from_select(
                [visitors.c.product_id, visitors.c.date, visitors.c.count],
                select([literal(product_id), literal(day), literal(count)])
                    .where(~exists(update_cte.select()))
            )

            connection.execute(upsert)

        .. seealso::

            :meth:`.orm.query.Query.cte` - ORM version of
            :meth:`_expression.HasCTE.cte`.

        """
        ...
    


class FromGrouping(FromClause):
    """Represent a grouping of a FROM clause"""
    __visit_name__ = ...
    def __init__(self, element) -> None:
        ...
    
    @property
    def columns(self):
        ...
    
    @property
    def primary_key(self):
        ...
    
    @property
    def foreign_keys(self):
        ...
    
    def is_derived_from(self, element):
        ...
    
    def alias(self, **kw):
        ...
    
    def get_children(self, **kwargs):
        ...
    
    def __getattr__(self, attr):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    


class TableClause(Immutable, FromClause):
    """Represents a minimal "table" construct.

    This is a lightweight table object that has only a name, a
    collection of columns, which are typically produced
    by the :func:`_expression.column` function, and a schema::

        from sqlalchemy import table, column

        user = table("user",
                column("id"),
                column("name"),
                column("description"),
        )

    The :class:`_expression.TableClause` construct serves as the base for
    the more commonly used :class:`_schema.Table` object, providing
    the usual set of :class:`_expression.FromClause` services including
    the ``.c.`` collection and statement generation methods.

    It does **not** provide all the additional schema-level services
    of :class:`_schema.Table`, including constraints, references to other
    tables, or support for :class:`_schema.MetaData`-level services.
    It's useful
    on its own as an ad-hoc construct used to generate quick SQL
    statements when a more fully fledged :class:`_schema.Table`
    is not on hand.

    """
    __visit_name__ = ...
    named_with_column = ...
    implicit_returning = ...
    _autoincrement_column = ...
    def __init__(self, name, *columns, **kw) -> None:
        """Produce a new :class:`_expression.TableClause`.

        The object returned is an instance of
        :class:`_expression.TableClause`, which
        represents the "syntactical" portion of the schema-level
        :class:`_schema.Table` object.
        It may be used to construct lightweight table constructs.

        .. versionchanged:: 1.0.0 :func:`_expression.table` can now
           be imported from the plain ``sqlalchemy`` namespace like any
           other SQL element.


        :param name: Name of the table.

        :param columns: A collection of :func:`_expression.column` constructs.

        :param schema: The schema name for this table.

            .. versionadded:: 1.3.18 :func:`_expression.table` can now
               accept a ``schema`` argument.
        """
        ...
    
    @util.memoized_property
    def description(self):
        ...
    
    def append_column(self, c):
        ...
    
    def get_children(self, column_collections=..., **kwargs):
        ...
    
    @util.dependencies("sqlalchemy.sql.dml")
    def insert(self, dml, values=..., inline=..., **kwargs):
        """Generate an :func:`_expression.insert` construct against this
        :class:`_expression.TableClause`.

        E.g.::

            table.insert().values(name='foo')

        See :func:`_expression.insert` for argument and usage information.

        """
        ...
    
    @util.dependencies("sqlalchemy.sql.dml")
    def update(self, dml, whereclause=..., values=..., inline=..., **kwargs):
        """Generate an :func:`_expression.update` construct against this
        :class:`_expression.TableClause`.

        E.g.::

            table.update().where(table.c.id==7).values(name='foo')

        See :func:`_expression.update` for argument and usage information.

        """
        ...
    
    @util.dependencies("sqlalchemy.sql.dml")
    def delete(self, dml, whereclause=..., **kwargs):
        """Generate a :func:`_expression.delete` construct against this
        :class:`_expression.TableClause`.

        E.g.::

            table.delete().where(table.c.id==7)

        See :func:`_expression.delete` for argument and usage information.

        """
        ...
    


class ForUpdateArg(ClauseElement):
    @classmethod
    def parse_legacy_select(self, arg):
        """Parse the for_update argument of :func:`_expression.select`.

        :param mode: Defines the lockmode to use.

            ``None`` - translates to no lockmode

            ``'update'`` - translates to ``FOR UPDATE``
            (standard SQL, supported by most dialects)

            ``'nowait'`` - translates to ``FOR UPDATE NOWAIT``
            (supported by Oracle, PostgreSQL 8.1 upwards)

            ``'read'`` - translates to ``LOCK IN SHARE MODE`` (for MySQL),
            and ``FOR SHARE`` (for PostgreSQL)

            ``'read_nowait'`` - translates to ``FOR SHARE NOWAIT``
            (supported by PostgreSQL). ``FOR SHARE`` and
            ``FOR SHARE NOWAIT`` (PostgreSQL).

        """
        ...
    
    @property
    def legacy_for_update_value(self):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __init__(self, nowait=..., read=..., of=..., skip_locked=..., key_share=...) -> None:
        """Represents arguments specified to
        :meth:`_expression.Select.for_update`.

        .. versionadded:: 0.9.0

        """
        ...
    


class SelectBase(HasCTE, Executable, FromClause):
    """Base class for SELECT statements.


    This includes :class:`_expression.Select`,
    :class:`_selectable.CompoundSelect` and
    :class:`.TextAsFrom`.


    """
    def as_scalar(self):
        """Return a 'scalar' representation of this selectable, which can be
        used as a column expression.

        Typically, a select statement which has only one column in its columns
        clause is eligible to be used as a scalar expression.

        The returned object is an instance of
        :class:`ScalarSelect`.

        """
        ...
    
    def label(self, name):
        """Return a 'scalar' representation of this selectable, embedded as a
        subquery with a label.

        .. seealso::

            :meth:`_expression.SelectBase.as_scalar`.

        """
        ...
    
    @_generative
    @util.deprecated("0.6", message="The :meth:`.SelectBase.autocommit` method is deprecated, " "and will be removed in a future release.   Please use the " "the :paramref:`.Connection.execution_options.autocommit` " "parameter in conjunction with the " ":meth:`.Executable.execution_options` method.")
    def autocommit(self):
        """Return a new selectable with the 'autocommit' flag set to
        True.

        """
        ...
    


class GenerativeSelect(SelectBase):
    """Base class for SELECT statements where additional elements can be
    added.

    This serves as the base for :class:`_expression.Select` and
    :class:`_selectable.CompoundSelect`
    where elements such as ORDER BY, GROUP BY can be added and column
    rendering can be controlled.  Compare to :class:`.TextAsFrom`, which,
    while it subclasses :class:`_expression.SelectBase`
    and is also a SELECT construct,
    represents a fixed textual string which cannot be altered at this level,
    only wrapped as a subquery.

    .. versionadded:: 0.9.0 :class:`_expression.GenerativeSelect` was added to
       provide functionality specific to :class:`_expression.Select` and
       :class:`_selectable.CompoundSelect` while allowing
       :class:`_expression.SelectBase` to be
       used for other SELECT-like objects, e.g. :class:`.TextAsFrom`.

    """
    _order_by_clause = ...
    _group_by_clause = ...
    _limit_clause = ...
    _offset_clause = ...
    _for_update_arg = ...
    def __init__(self, use_labels=..., for_update=..., limit=..., offset=..., order_by=..., group_by=..., bind=..., autocommit=...) -> None:
        ...
    
    @property
    def for_update(self):
        """Provide legacy dialect support for the ``for_update`` attribute."""
        ...
    
    @for_update.setter
    def for_update(self, value):
        ...
    
    @_generative
    def with_for_update(self, nowait=..., read=..., of=..., skip_locked=..., key_share=...):
        """Specify a ``FOR UPDATE`` clause for this
        :class:`_expression.GenerativeSelect`.

        E.g.::

            stmt = select([table]).with_for_update(nowait=True)

        On a database like PostgreSQL or Oracle, the above would render a
        statement like::

            SELECT table.a, table.b FROM table FOR UPDATE NOWAIT

        on other backends, the ``nowait`` option is ignored and instead
        would produce::

            SELECT table.a, table.b FROM table FOR UPDATE

        When called with no arguments, the statement will render with
        the suffix ``FOR UPDATE``.   Additional arguments can then be
        provided which allow for common database-specific
        variants.

        :param nowait: boolean; will render ``FOR UPDATE NOWAIT`` on Oracle
         and PostgreSQL dialects.

        :param read: boolean; will render ``LOCK IN SHARE MODE`` on MySQL,
         ``FOR SHARE`` on PostgreSQL.  On PostgreSQL, when combined with
         ``nowait``, will render ``FOR SHARE NOWAIT``.

        :param of: SQL expression or list of SQL expression elements
         (typically :class:`_schema.Column`
         objects or a compatible expression) which
         will render into a ``FOR UPDATE OF`` clause; supported by PostgreSQL
         and Oracle.  May render as a table or as a column depending on
         backend.

        :param skip_locked: boolean, will render ``FOR UPDATE SKIP LOCKED``
         on Oracle and PostgreSQL dialects or ``FOR SHARE SKIP LOCKED`` if
         ``read=True`` is also specified.

         .. versionadded:: 1.1.0

        :param key_share: boolean, will render ``FOR NO KEY UPDATE``,
         or if combined with ``read=True`` will render ``FOR KEY SHARE``,
         on the PostgreSQL dialect.

         .. versionadded:: 1.1.0

        """
        ...
    
    @_generative
    def apply_labels(self):
        """Return a new selectable with the 'use_labels' flag set to True.

        This will result in column expressions being generated using labels
        against their table name, such as "SELECT somecolumn AS
        tablename_somecolumn". This allows selectables which contain multiple
        FROM clauses to produce a unique set of column names regardless of
        name conflicts among the individual FROM clauses.

        """
        ...
    
    @_generative
    def limit(self, limit):
        """Return a new selectable with the given LIMIT criterion
        applied.

        This is a numerical value which usually renders as a ``LIMIT``
        expression in the resulting select.  Backends that don't
        support ``LIMIT`` will attempt to provide similar
        functionality.

        .. versionchanged:: 1.0.0 - :meth:`_expression.Select.limit` can now
           accept arbitrary SQL expressions as well as integer values.

        :param limit: an integer LIMIT parameter, or a SQL expression
         that provides an integer result.

        """
        ...
    
    @_generative
    def offset(self, offset):
        """Return a new selectable with the given OFFSET criterion
        applied.


        This is a numeric value which usually renders as an ``OFFSET``
        expression in the resulting select.  Backends that don't
        support ``OFFSET`` will attempt to provide similar
        functionality.


        .. versionchanged:: 1.0.0 - :meth:`_expression.Select.offset` can now
           accept arbitrary SQL expressions as well as integer values.

        :param offset: an integer OFFSET parameter, or a SQL expression
         that provides an integer result.

        """
        ...
    
    @_generative
    def order_by(self, *clauses):
        r"""Return a new selectable with the given list of ORDER BY
        criterion applied.

        e.g.::

            stmt = select([table]).order_by(table.c.id, table.c.name)

        :param \*clauses: a series of :class:`_expression.ColumnElement`
         constructs
         which will be used to generate an ORDER BY clause.

        .. seealso::

            :ref:`core_tutorial_ordering`

        """
        ...
    
    @_generative
    def group_by(self, *clauses):
        r"""Return a new selectable with the given list of GROUP BY
        criterion applied.

        e.g.::

            stmt = select([table.c.name, func.max(table.c.stat)]).\
            group_by(table.c.name)

        :param \*clauses: a series of :class:`_expression.ColumnElement`
         constructs
         which will be used to generate an GROUP BY clause.

        .. seealso::

            :ref:`core_tutorial_ordering`

        """
        ...
    
    def append_order_by(self, *clauses):
        """Append the given ORDER BY criterion applied to this selectable.

        The criterion will be appended to any pre-existing ORDER BY criterion.

        This is an **in-place** mutation method; the
        :meth:`_expression.GenerativeSelect.order_by` method is preferred,
        as it
        provides standard :term:`method chaining`.

        .. seealso::

            :meth:`_expression.GenerativeSelect.order_by`

        """
        ...
    
    def append_group_by(self, *clauses):
        """Append the given GROUP BY criterion applied to this selectable.

        The criterion will be appended to any pre-existing GROUP BY criterion.

        This is an **in-place** mutation method; the
        :meth:`_expression.GenerativeSelect.group_by` method is preferred,
        as it provides standard :term:`method chaining`.

        .. seealso::

            :meth:`_expression.GenerativeSelect.group_by`

        """
        ...
    


class CompoundSelect(GenerativeSelect):
    """Forms the basis of ``UNION``, ``UNION ALL``, and other
    SELECT-based set operations.


    .. seealso::

        :func:`_expression.union`

        :func:`_expression.union_all`

        :func:`_expression.intersect`

        :func:`_expression.intersect_all`

        :func:`_expression.except`

        :func:`_expression.except_all`

    """
    __visit_name__ = ...
    UNION = ...
    UNION_ALL = ...
    EXCEPT = ...
    EXCEPT_ALL = ...
    INTERSECT = ...
    INTERSECT_ALL = ...
    _is_from_container = ...
    def __init__(self, keyword, *selects, **kwargs) -> None:
        ...
    
    def self_group(self, against=...):
        ...
    
    def is_derived_from(self, fromclause):
        ...
    
    def get_children(self, column_collections=..., **kwargs):
        ...
    
    def bind(self):
        ...
    
    bind = ...


class Select(HasPrefixes, HasSuffixes, GenerativeSelect):
    """Represents a ``SELECT`` statement."""
    __visit_name__ = ...
    _prefixes = ...
    _suffixes = ...
    _hints = ...
    _statement_hints = ...
    _distinct = ...
    _from_cloned = ...
    _correlate = ...
    _correlate_except = ...
    _memoized_property = ...
    _is_select = ...
    @util.deprecated_params(autocommit=("0.6", "The :paramref:`_expression.select.autocommit` " "parameter is deprecated " "and will be removed in a future release.  Please refer to " "the :paramref:`.Connection.execution_options.autocommit` " "parameter in conjunction with the the " ":meth:`.Executable.execution_options` method in order to " "affect the autocommit behavior for a statement."), for_update=("0.9", "The :paramref:`_expression.select.for_update` " "parameter is deprecated and " "will be removed in a future release.  Please refer to the " ":meth:`_expression.Select.with_for_update` to specify the " "structure of the ``FOR UPDATE`` clause."))
    def __init__(self, columns=..., whereclause=..., from_obj=..., distinct=..., having=..., correlate=..., prefixes=..., suffixes=..., **kwargs) -> None:
        """Construct a new :class:`_expression.Select`.

        Similar functionality is also available via the
        :meth:`_expression.FromClause.select` method on any
        :class:`_expression.FromClause`.

        All arguments which accept :class:`_expression.ClauseElement`
        arguments also
        accept string arguments, which will be converted as appropriate into
        either :func:`_expression.text` or
        :func:`_expression.literal_column` constructs.

        .. seealso::

            :ref:`coretutorial_selecting` - Core Tutorial description of
            :func:`_expression.select`.

        :param columns:
          A list of :class:`_expression.ColumnElement` or
          :class:`_expression.FromClause`
          objects which will form the columns clause of the resulting
          statement.   For those objects that are instances of
          :class:`_expression.FromClause` (typically :class:`_schema.Table`
          or :class:`_expression.Alias`
          objects), the :attr:`_expression.FromClause.c`
          collection is extracted
          to form a collection of :class:`_expression.ColumnElement` objects.

          This parameter will also accept :class:`_expression.TextClause`
          constructs as
          given, as well as ORM-mapped classes.

          .. note::

            The :paramref:`_expression.select.columns`
            parameter is not available
            in the method form of :func:`_expression.select`, e.g.
            :meth:`_expression.FromClause.select`.

          .. seealso::

            :meth:`_expression.Select.column`

            :meth:`_expression.Select.with_only_columns`

        :param whereclause:
          A :class:`_expression.ClauseElement`
          expression which will be used to form the
          ``WHERE`` clause.   It is typically preferable to add WHERE
          criterion to an existing :class:`_expression.Select`
          using method chaining
          with :meth:`_expression.Select.where`.

          .. seealso::

            :meth:`_expression.Select.where`

        :param from_obj:
          A list of :class:`_expression.ClauseElement`
          objects which will be added to the
          ``FROM`` clause of the resulting statement.  This is equivalent
          to calling :meth:`_expression.Select.select_from`
          using method chaining on
          an existing :class:`_expression.Select` object.

          .. seealso::

            :meth:`_expression.Select.select_from`
            - full description of explicit
            FROM clause specification.

        :param autocommit: legacy autocommit parameter.

        :param bind=None:
          an :class:`_engine.Engine` or :class:`_engine.Connection` instance
          to which the
          resulting :class:`_expression.Select` object will be bound.  The
          :class:`_expression.Select`
          object will otherwise automatically bind to
          whatever :class:`~.base.Connectable` instances can be located within
          its contained :class:`_expression.ClauseElement` members.

        :param correlate=True:
          indicates that this :class:`_expression.Select`
          object should have its
          contained :class:`_expression.FromClause`
          elements "correlated" to an enclosing
          :class:`_expression.Select` object.
          It is typically preferable to specify
          correlations on an existing :class:`_expression.Select`
          construct using
          :meth:`_expression.Select.correlate`.

          .. seealso::

            :meth:`_expression.Select.correlate`
            - full description of correlation.

        :param distinct=False:
          when ``True``, applies a ``DISTINCT`` qualifier to the columns
          clause of the resulting statement.

          The boolean argument may also be a column expression or list
          of column expressions - this is a special calling form which
          is understood by the PostgreSQL dialect to render the
          ``DISTINCT ON (<columns>)`` syntax.

          ``distinct`` is also available on an existing
          :class:`_expression.Select`
          object via the :meth:`_expression.Select.distinct` method.

          .. seealso::

            :meth:`_expression.Select.distinct`

        :param for_update=False:
          when ``True``, applies ``FOR UPDATE`` to the end of the
          resulting statement.

          ``for_update`` accepts various string values interpreted by
          specific backends, including:

          * ``"read"`` - on MySQL, translates to ``LOCK IN SHARE MODE``;
            on PostgreSQL, translates to ``FOR SHARE``.
          * ``"nowait"`` - on PostgreSQL and Oracle, translates to
            ``FOR UPDATE NOWAIT``.
          * ``"read_nowait"`` - on PostgreSQL, translates to
            ``FOR SHARE NOWAIT``.

         .. seealso::

            :meth:`_expression.Select.with_for_update` - improved API for
            specifying the ``FOR UPDATE`` clause.

        :param group_by:
          a list of :class:`_expression.ClauseElement`
          objects which will comprise the
          ``GROUP BY`` clause of the resulting select.  This parameter
          is typically specified more naturally using the
          :meth:`_expression.Select.group_by` method on an existing
          :class:`_expression.Select`.

          .. seealso::

            :meth:`_expression.Select.group_by`

        :param having:
          a :class:`_expression.ClauseElement`
          that will comprise the ``HAVING`` clause
          of the resulting select when ``GROUP BY`` is used.  This parameter
          is typically specified more naturally using the
          :meth:`_expression.Select.having` method on an existing
          :class:`_expression.Select`.

          .. seealso::

            :meth:`_expression.Select.having`

        :param limit=None:
          a numerical value which usually renders as a ``LIMIT``
          expression in the resulting select.  Backends that don't
          support ``LIMIT`` will attempt to provide similar
          functionality.    This parameter is typically specified more
          naturally using the :meth:`_expression.Select.limit`
          method on an existing
          :class:`_expression.Select`.

          .. seealso::

            :meth:`_expression.Select.limit`

        :param offset=None:
          a numeric value which usually renders as an ``OFFSET``
          expression in the resulting select.  Backends that don't
          support ``OFFSET`` will attempt to provide similar
          functionality.  This parameter is typically specified more naturally
          using the :meth:`_expression.Select.offset` method on an existing
          :class:`_expression.Select`.

          .. seealso::

            :meth:`_expression.Select.offset`

        :param order_by:
          a scalar or list of :class:`_expression.ClauseElement`
          objects which will
          comprise the ``ORDER BY`` clause of the resulting select.
          This parameter is typically specified more naturally using the
          :meth:`_expression.Select.order_by` method on an existing
          :class:`_expression.Select`.

          .. seealso::

            :meth:`_expression.Select.order_by`

        :param use_labels=False:
          when ``True``, the statement will be generated using labels
          for each column in the columns clause, which qualify each
          column with its parent table's (or aliases) name so that name
          conflicts between columns in different tables don't occur.
          The format of the label is ``<tablename>_<column>``.  The "c"
          collection of the resulting :class:`_expression.Select`
          object will use these
          names as well for targeting column members.

          This parameter can also be specified on an existing
          :class:`_expression.Select` object using the
          :meth:`_expression.Select.apply_labels`
          method.

          .. seealso::

            :meth:`_expression.Select.apply_labels`

        """
        ...
    
    @property
    def froms(self):
        """Return the displayed list of FromClause elements."""
        ...
    
    def with_statement_hint(self, text, dialect_name=...):
        """Add a statement hint to this :class:`_expression.Select`.

        This method is similar to :meth:`_expression.Select.with_hint`
        except that
        it does not require an individual table, and instead applies to the
        statement as a whole.

        Hints here are specific to the backend database and may include
        directives such as isolation levels, file directives, fetch directives,
        etc.

        .. versionadded:: 1.0.0

        .. seealso::

            :meth:`_expression.Select.with_hint`

            :meth:`.Select.prefix_with` - generic SELECT prefixing which also
            can suit some database-specific HINT syntaxes such as MySQL
            optimizer hints

        """
        ...
    
    @_generative
    def with_hint(self, selectable, text, dialect_name=...):
        r"""Add an indexing or other executional context hint for the given
        selectable to this :class:`_expression.Select`.

        The text of the hint is rendered in the appropriate
        location for the database backend in use, relative
        to the given :class:`_schema.Table` or :class:`_expression.Alias`
        passed as the
        ``selectable`` argument. The dialect implementation
        typically uses Python string substitution syntax
        with the token ``%(name)s`` to render the name of
        the table or alias. E.g. when using Oracle, the
        following::

            select([mytable]).\
                with_hint(mytable, "index(%(name)s ix_mytable)")

        Would render SQL as::

            select /*+ index(mytable ix_mytable) */ ... from mytable

        The ``dialect_name`` option will limit the rendering of a particular
        hint to a particular backend. Such as, to add hints for both Oracle
        and Sybase simultaneously::

            select([mytable]).\
                with_hint(mytable, "index(%(name)s ix_mytable)", 'oracle').\
                with_hint(mytable, "WITH INDEX ix_mytable", 'sybase')

        .. seealso::

            :meth:`_expression.Select.with_statement_hint`

        """
        ...
    
    @property
    def type(self):
        ...
    
    @_memoized_property.method
    def locate_all_froms(self):
        """Return a Set of all :class:`_expression.FromClause` elements
        referenced by this Select.

        This set is a superset of that returned by the ``froms`` property,
        which is specifically for those FromClause elements that would
        actually be rendered.

        """
        ...
    
    @property
    def inner_columns(self):
        """An iterator of all :class:`_expression.ColumnElement`
        expressions which would
        be rendered into the columns clause of the resulting SELECT statement.

        """
        ...
    
    def is_derived_from(self, fromclause):
        ...
    
    def get_children(self, column_collections=..., **kwargs):
        """Return child elements as per the ClauseElement specification."""
        ...
    
    @_generative
    def column(self, column):
        """Return a new :func:`_expression.select` construct with
        the given column expression added to its columns clause.

        E.g.::

            my_select = my_select.column(table.c.new_column)

        See the documentation for
        :meth:`_expression.Select.with_only_columns`
        for guidelines on adding /replacing the columns of a
        :class:`_expression.Select` object.

        """
        ...
    
    @util.dependencies("sqlalchemy.sql.util")
    def reduce_columns(self, sqlutil, only_synonyms=...):
        """Return a new :func:`_expression.select` construct with redundantly
        named, equivalently-valued columns removed from the columns clause.

        "Redundant" here means two columns where one refers to the
        other either based on foreign key, or via a simple equality
        comparison in the WHERE clause of the statement.   The primary purpose
        of this method is to automatically construct a select statement
        with all uniquely-named columns, without the need to use
        table-qualified labels as :meth:`_expression.Select.apply_labels`
        does.

        When columns are omitted based on foreign key, the referred-to
        column is the one that's kept.  When columns are omitted based on
        WHERE equivalence, the first column in the columns clause is the
        one that's kept.

        :param only_synonyms: when True, limit the removal of columns
         to those which have the same name as the equivalent.   Otherwise,
         all columns that are equivalent to another are removed.

        """
        ...
    
    @_generative
    def with_only_columns(self, columns):
        r"""Return a new :func:`_expression.select` construct with its columns
        clause replaced with the given columns.

        This method is exactly equivalent to as if the original
        :func:`_expression.select` had been called with the given columns
        clause.   I.e. a statement::

            s = select([table1.c.a, table1.c.b])
            s = s.with_only_columns([table1.c.b])

        should be exactly equivalent to::

            s = select([table1.c.b])

        This means that FROM clauses which are only derived
        from the column list will be discarded if the new column
        list no longer contains that FROM::

            >>> table1 = table('t1', column('a'), column('b'))
            >>> table2 = table('t2', column('a'), column('b'))
            >>> s1 = select([table1.c.a, table2.c.b])
            >>> print(s1)
            SELECT t1.a, t2.b FROM t1, t2
            >>> s2 = s1.with_only_columns([table2.c.b])
            >>> print(s2)
            SELECT t2.b FROM t1

        The preferred way to maintain a specific FROM clause
        in the construct, assuming it won't be represented anywhere
        else (i.e. not in the WHERE clause, etc.) is to set it using
        :meth:`_expression.Select.select_from`::

            >>> s1 = select([table1.c.a, table2.c.b]).\
            ...         select_from(table1.join(table2,
            ...                 table1.c.a==table2.c.a))
            >>> s2 = s1.with_only_columns([table2.c.b])
            >>> print(s2)
            SELECT t2.b FROM t1 JOIN t2 ON t1.a=t2.a

        Care should also be taken to use the correct set of column objects
        passed to :meth:`_expression.Select.with_only_columns`.
        Since the method is
        essentially equivalent to calling the :func:`_expression.select`
        construct in the first place with the given columns, the columns passed
        to :meth:`_expression.Select.with_only_columns`
        should usually be a subset of
        those which were passed to the :func:`_expression.select`
        construct, not those which are available from the ``.c`` collection of
        that :func:`_expression.select`.  That is::

            s = select([table1.c.a, table1.c.b]).select_from(table1)
            s = s.with_only_columns([table1.c.b])

        and **not**::

            # usually incorrect
            s = s.with_only_columns([s.c.b])

        The latter would produce the SQL::

            SELECT b
            FROM (SELECT t1.a AS a, t1.b AS b
            FROM t1), t1

        Since the :func:`_expression.select` construct is essentially
        being asked to select both from ``table1`` as well as itself.

        """
        ...
    
    @_generative
    def where(self, whereclause):
        """Return a new :func:`_expression.select` construct with
        the given expression added to
        its WHERE clause, joined to the existing clause via AND, if any.

        """
        ...
    
    @_generative
    def having(self, having):
        """Return a new :func:`_expression.select` construct with
        the given expression added to
        its HAVING clause, joined to the existing clause via AND, if any.

        """
        ...
    
    @_generative
    def distinct(self, *expr):
        r"""Return a new :func:`_expression.select` construct which
        will apply DISTINCT to its columns clause.

        :param \*expr: optional column expressions.  When present,
         the PostgreSQL dialect will render a ``DISTINCT ON (<expressions>>)``
         construct.

        """
        ...
    
    @_generative
    def select_from(self, fromclause):
        r"""Return a new :func:`_expression.select` construct with the
        given FROM expression(s)
        merged into its list of FROM objects.

        E.g.::

            table1 = table('t1', column('a'))
            table2 = table('t2', column('b'))
            s = select([table1.c.a]).\
                select_from(
                    table1.join(table2, table1.c.a==table2.c.b)
                )

        The "from" list is a unique set on the identity of each element,
        so adding an already present :class:`_schema.Table`
        or other selectable
        will have no effect.   Passing a :class:`_expression.Join` that refers
        to an already present :class:`_schema.Table`
        or other selectable will have
        the effect of concealing the presence of that selectable as
        an individual element in the rendered FROM list, instead
        rendering it into a JOIN clause.

        While the typical purpose of :meth:`_expression.Select.select_from`
        is to
        replace the default, derived FROM clause with a join, it can
        also be called with individual table elements, multiple times
        if desired, in the case that the FROM clause cannot be fully
        derived from the columns clause::

            select([func.count('*')]).select_from(table1)

        """
        ...
    
    @_generative
    def correlate(self, *fromclauses):
        r"""Return a new :class:`_expression.Select`
        which will correlate the given FROM
        clauses to that of an enclosing :class:`_expression.Select`.

        Calling this method turns off the :class:`_expression.Select` object's
        default behavior of "auto-correlation".  Normally, FROM elements
        which appear in a :class:`_expression.Select`
        that encloses this one via
        its :term:`WHERE clause`, ORDER BY, HAVING or
        :term:`columns clause` will be omitted from this
        :class:`_expression.Select`
        object's :term:`FROM clause`.
        Setting an explicit correlation collection using the
        :meth:`_expression.Select.correlate`
        method provides a fixed list of FROM objects
        that can potentially take place in this process.

        When :meth:`_expression.Select.correlate`
        is used to apply specific FROM clauses
        for correlation, the FROM elements become candidates for
        correlation regardless of how deeply nested this
        :class:`_expression.Select`
        object is, relative to an enclosing :class:`_expression.Select`
        which refers to
        the same FROM object.  This is in contrast to the behavior of
        "auto-correlation" which only correlates to an immediate enclosing
        :class:`_expression.Select`.
        Multi-level correlation ensures that the link
        between enclosed and enclosing :class:`_expression.Select`
        is always via
        at least one WHERE/ORDER BY/HAVING/columns clause in order for
        correlation to take place.

        If ``None`` is passed, the :class:`_expression.Select`
        object will correlate
        none of its FROM entries, and all will render unconditionally
        in the local FROM clause.

        :param \*fromclauses: a list of one or more
         :class:`_expression.FromClause`
         constructs, or other compatible constructs (i.e. ORM-mapped
         classes) to become part of the correlate collection.

        .. seealso::

            :meth:`_expression.Select.correlate_except`

            :ref:`correlated_subqueries`

        """
        ...
    
    @_generative
    def correlate_except(self, *fromclauses):
        r"""Return a new :class:`_expression.Select`
        which will omit the given FROM
        clauses from the auto-correlation process.

        Calling :meth:`_expression.Select.correlate_except` turns off the
        :class:`_expression.Select` object's default behavior of
        "auto-correlation" for the given FROM elements.  An element
        specified here will unconditionally appear in the FROM list, while
        all other FROM elements remain subject to normal auto-correlation
        behaviors.

        If ``None`` is passed, the :class:`_expression.Select`
        object will correlate
        all of its FROM entries.

        :param \*fromclauses: a list of one or more
         :class:`_expression.FromClause`
         constructs, or other compatible constructs (i.e. ORM-mapped
         classes) to become part of the correlate-exception collection.

        .. seealso::

            :meth:`_expression.Select.correlate`

            :ref:`correlated_subqueries`

        """
        ...
    
    def append_correlation(self, fromclause):
        """Append the given correlation expression to this
        :func:`_expression.select` construct.

        This is an **in-place** mutation method; the
        :meth:`_expression.Select.correlate` method is preferred,
        as it provides standard :term:`method chaining`.

        """
        ...
    
    def append_column(self, column):
        """Append the given column expression to the columns clause of this
        :func:`_expression.select` construct.

        E.g.::

            my_select.append_column(some_table.c.new_column)

        This is an **in-place** mutation method; the
        :meth:`_expression.Select.column` method is preferred,
        as it provides standard :term:`method chaining`.

        See the documentation for :meth:`_expression.Select.with_only_columns`
        for guidelines on adding /replacing the columns of a
        :class:`_expression.Select` object.

        """
        ...
    
    def append_prefix(self, clause):
        """Append the given columns clause prefix expression to this
        :func:`_expression.select` construct.

        This is an **in-place** mutation method; the
        :meth:`_expression.Select.prefix_with` method is preferred,
        as it provides standard :term:`method chaining`.

        """
        ...
    
    def append_whereclause(self, whereclause):
        """Append the given expression to this :func:`_expression.select`
        construct's WHERE criterion.

        The expression will be joined to existing WHERE criterion via AND.

        This is an **in-place** mutation method; the
        :meth:`_expression.Select.where` method is preferred,
        as it provides standard :term:`method chaining`.

        """
        ...
    
    def append_having(self, having):
        """Append the given expression to this :func:`_expression.select`
        construct's HAVING criterion.

        The expression will be joined to existing HAVING criterion via AND.

        This is an **in-place** mutation method; the
        :meth:`_expression.Select.having` method is preferred,
        as it provides standard :term:`method chaining`.

        """
        ...
    
    def append_from(self, fromclause):
        """Append the given FromClause expression to this
        :func:`_expression.select` construct's FROM clause.

        This is an **in-place** mutation method; the
        :meth:`_expression.Select.select_from` method is preferred,
        as it provides standard :term:`method chaining`.

        """
        ...
    
    def self_group(self, against=...):
        """Return a 'grouping' construct as per the
        :class:`_expression.ClauseElement` specification.

        This produces an element that can be embedded in an expression. Note
        that this method is called automatically as needed when constructing
        expressions and should not require explicit use.

        """
        ...
    
    def union(self, other, **kwargs):
        """Return a SQL ``UNION`` of this select() construct against
        the given selectable.

        """
        ...
    
    def union_all(self, other, **kwargs):
        """Return a SQL ``UNION ALL`` of this select() construct against
        the given selectable.

        """
        ...
    
    def except_(self, other, **kwargs):
        """Return a SQL ``EXCEPT`` of this select() construct against
        the given selectable.

        """
        ...
    
    def except_all(self, other, **kwargs):
        """Return a SQL ``EXCEPT ALL`` of this select() construct against
        the given selectable.

        """
        ...
    
    def intersect(self, other, **kwargs):
        """Return a SQL ``INTERSECT`` of this select() construct against
        the given selectable.

        """
        ...
    
    def intersect_all(self, other, **kwargs):
        """Return a SQL ``INTERSECT ALL`` of this select() construct
        against the given selectable.

        """
        ...
    
    def bind(self):
        ...
    
    bind = ...


class ScalarSelect(Generative, Grouping):
    _from_objects = ...
    _is_from_container = ...
    _is_implicitly_boolean = ...
    def __init__(self, element) -> None:
        ...
    
    @property
    def columns(self):
        ...
    
    c = ...
    @_generative
    def where(self, crit):
        """Apply a WHERE clause to the SELECT statement referred to
        by this :class:`_expression.ScalarSelect`.

        """
        ...
    
    def self_group(self, **kwargs):
        ...
    


class Exists(UnaryExpression):
    """Represent an ``EXISTS`` clause."""
    __visit_name__ = ...
    _from_objects = ...
    def __init__(self, *args, **kwargs) -> None:
        """Construct a new :class:`_expression.Exists` against an existing
        :class:`_expression.Select` object.

        Calling styles are of the following forms::

            # use on an existing select()
            s = select([table.c.col1]).where(table.c.col2==5)
            s_e = exists(s)

            # an exists is usually used in a where of another select
            # to produce a WHERE EXISTS (SELECT ... )
            select([table.c.col1]).where(s_e)

            # but can also be used in a select to produce a
            # SELECT EXISTS (SELECT ... ) query
            select([s_e])

            # construct a select() at once
            exists(['*'], **select_arguments).where(criterion)

            # columns argument is optional, generates "EXISTS (SELECT *)"
            # by default.
            exists().where(table.c.col2==5)

        """
        ...
    
    def select(self, whereclause=..., **params):
        ...
    
    def correlate(self, *fromclause):
        ...
    
    def correlate_except(self, *fromclause):
        ...
    
    def select_from(self, clause):
        """Return a new :class:`_expression.Exists` construct,
        applying the given
        expression to the :meth:`_expression.Select.select_from`
        method of the select
        statement contained.

        """
        ...
    
    def where(self, clause):
        """Return a new :func:`_expression.exists` construct with the
        given expression added to
        its WHERE clause, joined to the existing clause via AND, if any.

        """
        ...
    


class TextAsFrom(SelectBase):
    """Wrap a :class:`_expression.TextClause` construct within a
    :class:`_expression.SelectBase`
    interface.

    This allows the :class:`_expression.TextClause` object to gain a
    ``.c`` collection
    and other FROM-like capabilities such as
    :meth:`_expression.FromClause.alias`,
    :meth:`_expression.SelectBase.cte`, etc.

    The :class:`.TextAsFrom` construct is produced via the
    :meth:`_expression.TextClause.columns`
    method - see that method for details.

    .. versionadded:: 0.9.0

    .. seealso::

        :func:`_expression.text`

        :meth:`_expression.TextClause.columns`

    """
    __visit_name__ = ...
    _textual = ...
    def __init__(self, text, columns, positional=...) -> None:
        ...
    
    @_generative
    def bindparams(self, *binds, **bind_as_values):
        ...
    


class AnnotatedFromClause(Annotated):
    def __init__(self, element, values) -> None:
        ...
    


