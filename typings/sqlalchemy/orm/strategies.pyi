"""
This type stub file was generated by pyright.
"""

from . import properties
from .interfaces import LoaderStrategy
from .. import log, util

"""sqlalchemy.orm.interfaces.LoaderStrategy
   implementations, and related MapperOptions."""
@properties.ColumnProperty.strategy_for(instrument=False, deferred=False)
class UninstrumentedColumnLoader(LoaderStrategy):
    """Represent a non-instrumented MapperProperty.

    The polymorphic_on argument of mapper() often results in this,
    if the argument is against the with_polymorphic selectable.

    """
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def setup_query(self, context, query_entity, path, loadopt, adapter, column_collection=..., **kwargs):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


@log.class_logger
@properties.ColumnProperty.strategy_for(instrument=True, deferred=False)
class ColumnLoader(LoaderStrategy):
    """Provide loading behavior for a :class:`.ColumnProperty`."""
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def setup_query(self, context, query_entity, path, loadopt, adapter, column_collection, memoized_populators, **kwargs):
        ...
    
    def init_class_attribute(self, mapper):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


@log.class_logger
@properties.ColumnProperty.strategy_for(query_expression=True)
class ExpressionColumnLoader(ColumnLoader):
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def setup_query(self, context, query_entity, path, loadopt, adapter, column_collection, memoized_populators, **kwargs):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    
    def init_class_attribute(self, mapper):
        ...
    


@log.class_logger
@properties.ColumnProperty.strategy_for(deferred=True, instrument=True)
@properties.ColumnProperty.strategy_for(do_nothing=True)
class DeferredColumnLoader(LoaderStrategy):
    """Provide loading behavior for a deferred :class:`.ColumnProperty`."""
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    
    def init_class_attribute(self, mapper):
        ...
    
    def setup_query(self, context, query_entity, path, loadopt, adapter, column_collection, memoized_populators, only_load_props=..., **kw):
        ...
    


class LoadDeferredColumns(object):
    """serializable loader object used by DeferredColumnLoader"""
    def __init__(self, key) -> None:
        ...
    
    def __call__(self, state, passive=...):
        ...
    


class AbstractRelationshipLoader(LoaderStrategy):
    """LoaderStratgies which deal with related objects."""
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    


@log.class_logger
@properties.RelationshipProperty.strategy_for(do_nothing=True)
class DoNothingLoader(LoaderStrategy):
    """Relationship loader that makes no change to the object's state.

    Compared to NoLoader, this loader does not initialize the
    collection/attribute to empty/none; the usual default LazyLoader will
    take effect.

    """
    ...


@log.class_logger
@properties.RelationshipProperty.strategy_for(lazy="noload")
@properties.RelationshipProperty.strategy_for(lazy=None)
class NoLoader(AbstractRelationshipLoader):
    """Provide loading behavior for a :class:`.RelationshipProperty`
    with "lazy=None".

    """
    __slots__ = ...
    def init_class_attribute(self, mapper):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


@log.class_logger
@properties.RelationshipProperty.strategy_for(lazy=True)
@properties.RelationshipProperty.strategy_for(lazy="select")
@properties.RelationshipProperty.strategy_for(lazy="raise")
@properties.RelationshipProperty.strategy_for(lazy="raise_on_sql")
@properties.RelationshipProperty.strategy_for(lazy="baked_select")
class LazyLoader(AbstractRelationshipLoader, util.MemoizedSlots):
    """Provide loading behavior for a :class:`.RelationshipProperty`
    with "lazy=True", that is loads when first accessed.

    """
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


class LoadLazyAttribute(object):
    """serializable loader object used by LazyLoader"""
    def __init__(self, key, initiating_strategy) -> None:
        ...
    
    def __call__(self, state, passive=...):
        ...
    


@properties.RelationshipProperty.strategy_for(lazy="immediate")
class ImmediateLoader(AbstractRelationshipLoader):
    __slots__ = ...
    def init_class_attribute(self, mapper):
        ...
    
    def setup_query(self, context, entity, path, loadopt, adapter, column_collection=..., parentmapper=..., **kwargs):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


@log.class_logger
@properties.RelationshipProperty.strategy_for(lazy="subquery")
class SubqueryLoader(AbstractRelationshipLoader):
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper):
        ...
    
    def setup_query(self, context, entity, path, loadopt, adapter, column_collection=..., parentmapper=..., **kwargs):
        ...
    
    class _SubqCollections(object):
        """Given a :class:`_query.Query` used to emit the "subquery load",
        provide a load interface that executes the query at the
        first moment a value is needed.

        """
        _data = ...
        def __init__(self, subq) -> None:
            ...
        
        def get(self, key, default):
            ...
        
        def loader(self, state, dict_, row):
            ...
        
    
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


@log.class_logger
@properties.RelationshipProperty.strategy_for(lazy="joined")
@properties.RelationshipProperty.strategy_for(lazy=False)
class JoinedLoader(AbstractRelationshipLoader):
    """Provide loading behavior for a :class:`.RelationshipProperty`
    using joined eager loading.

    """
    __slots__ = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper):
        ...
    
    def setup_query(self, context, query_entity, path, loadopt, adapter, column_collection=..., parentmapper=..., chained_from_outerjoin=..., **kwargs):
        """Add a left outer join to the statement that's being constructed."""
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


@log.class_logger
@properties.RelationshipProperty.strategy_for(lazy="selectin")
class SelectInLoader(AbstractRelationshipLoader, util.MemoizedSlots):
    __slots__ = ...
    query_info = ...
    _chunksize = ...
    def __init__(self, parent, strategy_key) -> None:
        ...
    
    def init_class_attribute(self, mapper):
        ...
    
    def create_row_processor(self, context, path, loadopt, mapper, result, adapter, populators):
        ...
    


def single_parent_validator(desc, prop):
    ...

