"""
This type stub file was generated by pyright.
"""

from .. import util

"""Define result set constructs including :class:`_engine.ResultProxy`
and :class:`.RowProxy`."""
class RowProxy(BaseRowProxy):
    """Represent a single result row.

    The :class:`.RowProxy` object is retrieved from a database result, from the
    :class:`_engine.ResultProxy` object using methods like
    :meth:`_engine.ResultProxy.fetchall`.

    The :class:`.RowProxy` object seeks to act mostly like a Python named
    tuple, but also provides some Python dictionary behaviors at the same time.

    .. seealso::

        :ref:`coretutorial_selecting` - includes examples of selecting
        rows from SELECT statements.

    """
    __slots__ = ...
    def __contains__(self, key):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    
    __hash__ = ...
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __repr__(self):
        ...
    
    def has_key(self, key):
        """Return True if this :class:`.RowProxy` contains the given key.

        Through the SQLAlchemy 1.x series, the ``__contains__()`` method
        of :class:`.RowProxy` also links to :meth:`.RowProxy.has_key`, in that
        an expression such as ::

            "some_col" in row

        Will return True if the row contains a column named ``"some_col"``,
        in the way that a Python mapping works.

        However, it is planned that the 2.0 series of SQLAlchemy will reverse
        this behavior so that ``__contains__()`` will refer to a value being
        present in the row, in the way that a Python tuple works.

        """
        ...
    
    def items(self):
        """Return a list of tuples, each tuple containing a key/value pair.

        This method is analogous to the Python dictionary ``.items()`` method,
        except that it returns a list, not an iterator.

        """
        ...
    
    def keys(self):
        """Return the list of keys as strings represented by this
        :class:`.RowProxy`.

        This method is analogous to the Python dictionary ``.keys()`` method,
        except that it returns a list, not an iterator.

        """
        ...
    
    def iterkeys(self):
        """Return a an iterator against the :meth:`.RowProxy.keys` method.

        This method is analogous to the Python-2-only dictionary
        ``.iterkeys()`` method.

        """
        ...
    
    def itervalues(self):
        """Return a an iterator against the :meth:`.RowProxy.values` method.

        This method is analogous to the Python-2-only dictionary
        ``.itervalues()`` method.

        """
        ...
    
    def values(self):
        """Return the values represented by this :class:`.RowProxy` as a list.

        This method is analogous to the Python dictionary ``.values()`` method,
        except that it returns a list, not an iterator.

        """
        ...
    


class ResultMetaData(object):
    """Handle cursor.description, applying additional info from an execution
    context."""
    __slots__ = ...
    def __init__(self, parent, cursor_description) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    


class ResultProxy(object):
    """A facade around a DBAPI cursor object.

    Returns database rows via the :class:`.RowProxy` class, which provides
    additional API features and behaviors on top of the raw data returned
    by the DBAPI.

    .. seealso::

        :ref:`coretutorial_selecting` - introductory material for accessing
        :class:`_engine.ResultProxy` and :class:`.RowProxy` objects.

    """
    _process_row = ...
    out_parameters = ...
    _autoclose_connection = ...
    _metadata = ...
    _soft_closed = ...
    closed = ...
    def __init__(self, context) -> None:
        ...
    
    def keys(self):
        """Return the list of string keys that would represented by each
        :class:`.RowProxy`."""
        ...
    
    @util.memoized_property
    def rowcount(self):
        """Return the 'rowcount' for this result.

        The 'rowcount' reports the number of rows *matched*
        by the WHERE criterion of an UPDATE or DELETE statement.

        .. note::

           Notes regarding :attr:`_engine.ResultProxy.rowcount`:


           * This attribute returns the number of rows *matched*,
             which is not necessarily the same as the number of rows
             that were actually *modified* - an UPDATE statement, for example,
             may have no net change on a given row if the SET values
             given are the same as those present in the row already.
             Such a row would be matched but not modified.
             On backends that feature both styles, such as MySQL,
             rowcount is configured by default to return the match
             count in all cases.

           * :attr:`_engine.ResultProxy.rowcount`
             is *only* useful in conjunction
             with an UPDATE or DELETE statement.  Contrary to what the Python
             DBAPI says, it does *not* return the
             number of rows available from the results of a SELECT statement
             as DBAPIs cannot support this functionality when rows are
             unbuffered.

           * :attr:`_engine.ResultProxy.rowcount`
             may not be fully implemented by
             all dialects.  In particular, most DBAPIs do not support an
             aggregate rowcount result from an executemany call.
             The :meth:`_engine.ResultProxy.supports_sane_rowcount` and
             :meth:`_engine.ResultProxy.supports_sane_multi_rowcount` methods
             will report from the dialect if each usage is known to be
             supported.

           * Statements that use RETURNING may not return a correct
             rowcount.

        """
        ...
    
    @property
    def lastrowid(self):
        """Return the 'lastrowid' accessor on the DBAPI cursor.

        This is a DBAPI specific method and is only functional
        for those backends which support it, for statements
        where it is appropriate.  It's behavior is not
        consistent across backends.

        Usage of this method is normally unnecessary when
        using insert() expression constructs; the
        :attr:`~ResultProxy.inserted_primary_key` attribute provides a
        tuple of primary key values for a newly inserted row,
        regardless of database backend.

        """
        ...
    
    @property
    def returns_rows(self):
        """True if this :class:`_engine.ResultProxy` returns rows.

        I.e. if it is legal to call the methods
        :meth:`_engine.ResultProxy.fetchone`,
        :meth:`_engine.ResultProxy.fetchmany`
        :meth:`_engine.ResultProxy.fetchall`.

        """
        ...
    
    @property
    def is_insert(self):
        """True if this :class:`_engine.ResultProxy` is the result
        of a executing an expression language compiled
        :func:`_expression.insert` construct.

        When True, this implies that the
        :attr:`inserted_primary_key` attribute is accessible,
        assuming the statement did not include
        a user defined "returning" construct.

        """
        ...
    
    def close(self):
        """Close this ResultProxy.

        This closes out the underlying DBAPI cursor corresponding
        to the statement execution, if one is still present.  Note that the
        DBAPI cursor is automatically released when the
        :class:`_engine.ResultProxy`
        exhausts all available rows.  :meth:`_engine.ResultProxy.close`
        is generally
        an optional method except in the case when discarding a
        :class:`_engine.ResultProxy`
        that still has additional rows pending for fetch.

        In the case of a result that is the product of
        :ref:`connectionless execution <dbengine_implicit>`,
        the underlying :class:`_engine.Connection` object is also closed,
        which
        :term:`releases` DBAPI connection resources.

        After this method is called, it is no longer valid to call upon
        the fetch methods, which will raise a :class:`.ResourceClosedError`
        on subsequent use.

        .. versionchanged:: 1.0.0 - the :meth:`_engine.ResultProxy.close`
           method
           has been separated out from the process that releases the underlying
           DBAPI cursor resource.   The "auto close" feature of the
           :class:`_engine.Connection` now performs a so-called "soft close",
           which
           releases the underlying DBAPI cursor, but allows the
           :class:`_engine.ResultProxy`
           to still behave as an open-but-exhausted
           result set; the actual :meth:`_engine.ResultProxy.close`
           method is never
           called.    It is still safe to discard a
           :class:`_engine.ResultProxy`
           that has been fully exhausted without calling this method.

        .. seealso::

            :ref:`connections_toplevel`

        """
        ...
    
    def __iter__(self):
        """Implement iteration protocol."""
        ...
    
    def __next__(self):
        """Implement the Python next() protocol.

        This method, mirrored as both ``.next()`` and  ``.__next__()``, is part
        of Python's API for producing iterator-like behavior.

        .. versionadded:: 1.2

        """
        ...
    
    next = ...
    @util.memoized_property
    def inserted_primary_key(self):
        """Return the primary key for the row just inserted.

        The return value is a list of scalar values
        corresponding to the list of primary key columns
        in the target table.

        This only applies to single row :func:`_expression.insert`
        constructs which did not explicitly specify
        :meth:`_expression.Insert.returning`.

        Note that primary key columns which specify a
        server_default clause,
        or otherwise do not qualify as "autoincrement"
        columns (see the notes at :class:`_schema.Column`), and were
        generated using the database-side default, will
        appear in this list as ``None`` unless the backend
        supports "returning" and the insert statement executed
        with the "implicit returning" enabled.

        Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
        statement is not a compiled expression construct
        or is not an insert() construct.

        """
        ...
    
    def last_updated_params(self):
        """Return the collection of updated parameters from this
        execution.

        Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
        statement is not a compiled expression construct
        or is not an update() construct.

        """
        ...
    
    def last_inserted_params(self):
        """Return the collection of inserted parameters from this
        execution.

        Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
        statement is not a compiled expression construct
        or is not an insert() construct.

        """
        ...
    
    @property
    def returned_defaults(self):
        """Return the values of default columns that were fetched using
        the :meth:`.ValuesBase.return_defaults` feature.

        The value is an instance of :class:`.RowProxy`, or ``None``
        if :meth:`.ValuesBase.return_defaults` was not used or if the
        backend does not support RETURNING.

        .. versionadded:: 0.9.0

        .. seealso::

            :meth:`.ValuesBase.return_defaults`

        """
        ...
    
    def lastrow_has_defaults(self):
        """Return ``lastrow_has_defaults()`` from the underlying
        :class:`.ExecutionContext`.

        See :class:`.ExecutionContext` for details.

        """
        ...
    
    def postfetch_cols(self):
        """Return ``postfetch_cols()`` from the underlying
        :class:`.ExecutionContext`.

        See :class:`.ExecutionContext` for details.

        Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
        statement is not a compiled expression construct
        or is not an insert() or update() construct.

        """
        ...
    
    def prefetch_cols(self):
        """Return ``prefetch_cols()`` from the underlying
        :class:`.ExecutionContext`.

        See :class:`.ExecutionContext` for details.

        Raises :class:`~sqlalchemy.exc.InvalidRequestError` if the executed
        statement is not a compiled expression construct
        or is not an insert() or update() construct.

        """
        ...
    
    def supports_sane_rowcount(self):
        """Return ``supports_sane_rowcount`` from the dialect.

        See :attr:`_engine.ResultProxy.rowcount` for background.

        """
        ...
    
    def supports_sane_multi_rowcount(self):
        """Return ``supports_sane_multi_rowcount`` from the dialect.

        See :attr:`_engine.ResultProxy.rowcount` for background.

        """
        ...
    
    def process_rows(self, rows):
        ...
    
    def fetchall(self):
        """Fetch all rows, just like DB-API ``cursor.fetchall()``.

        After all rows have been exhausted, the underlying DBAPI
        cursor resource is released, and the object may be safely
        discarded.

        Subsequent calls to :meth:`_engine.ResultProxy.fetchall` will return
        an empty list.   After the :meth:`_engine.ResultProxy.close` method is
        called, the method will raise :class:`.ResourceClosedError`.

        :return: a list of :class:`.RowProxy` objects

        """
        ...
    
    def fetchmany(self, size=...):
        """Fetch many rows, just like DB-API
        ``cursor.fetchmany(size=cursor.arraysize)``.

        After all rows have been exhausted, the underlying DBAPI
        cursor resource is released, and the object may be safely
        discarded.

        Calls to :meth:`_engine.ResultProxy.fetchmany`
        after all rows have been
        exhausted will return
        an empty list.   After the :meth:`_engine.ResultProxy.close` method is
        called, the method will raise :class:`.ResourceClosedError`.

        :return: a list of :class:`.RowProxy` objects

        """
        ...
    
    def fetchone(self):
        """Fetch one row, just like DB-API ``cursor.fetchone()``.

        After all rows have been exhausted, the underlying DBAPI
        cursor resource is released, and the object may be safely
        discarded.

        Calls to :meth:`_engine.ResultProxy.fetchone` after all rows have
        been exhausted will return ``None``.
        After the :meth:`_engine.ResultProxy.close` method is
        called, the method will raise :class:`.ResourceClosedError`.

        :return: a :class:`.RowProxy` object, or None if no rows remain

        """
        ...
    
    def first(self):
        """Fetch the first row and then close the result set unconditionally.

        After calling this method, the object is fully closed,
        e.g. the :meth:`_engine.ResultProxy.close`
        method will have been called.

        :return: a :class:`.RowProxy` object, or None if no rows remain

        """
        ...
    
    def scalar(self):
        """Fetch the first column of the first row, and close the result set.

        After calling this method, the object is fully closed,
        e.g. the :meth:`_engine.ResultProxy.close`
        method will have been called.

        :return: a Python scalar value , or None if no rows remain

        """
        ...
    


class BufferedRowResultProxy(ResultProxy):
    """A ResultProxy with row buffering behavior.

    ``ResultProxy`` that buffers the contents of a selection of rows
    before ``fetchone()`` is called.  This is to allow the results of
    ``cursor.description`` to be available immediately, when
    interfacing with a DB-API that requires rows to be consumed before
    this information is available (currently psycopg2, when used with
    server-side cursors).

    The pre-fetching behavior fetches only one row initially, and then
    grows its buffer size by a fixed amount with each successive need
    for additional rows up to a size of 1000.

    The size argument is configurable using the ``max_row_buffer``
    execution option::

        with psycopg2_engine.connect() as conn:

            result = conn.execution_options(
                stream_results=True, max_row_buffer=50
                ).execute("select * from table")

    .. versionadded:: 1.0.6 Added the ``max_row_buffer`` option.

    .. seealso::

        :ref:`psycopg2_execution_options`
    """
    size_growth = ...


class FullyBufferedResultProxy(ResultProxy):
    """A result proxy that buffers rows fully upon creation.

    Used for operations where a result is to be delivered
    after the database conversation can not be continued,
    such as MSSQL INSERT...OUTPUT after an autocommit.

    """
    ...


class BufferedColumnRow(RowProxy):
    def __init__(self, parent, row, processors, keymap) -> None:
        ...
    


class BufferedColumnResultProxy(ResultProxy):
    """A ResultProxy with column buffering behavior.

    ``ResultProxy`` that loads all columns into memory each time
    fetchone() is called.  If fetchmany() or fetchall() are called,
    the full grid of results is fetched.  This is to operate with
    databases where result rows contain "live" results that fall out
    of scope unless explicitly fetched.

    .. versionchanged:: 1.2  This :class:`_engine.ResultProxy` is not used by
       any SQLAlchemy-included dialects.

    """
    _process_row = ...
    def fetchall(self):
        ...
    
    def fetchmany(self, size=...):
        ...
    


