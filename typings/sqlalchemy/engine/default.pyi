"""
This type stub file was generated by pyright.
"""

import re
from . import interfaces
from .. import types as sqltypes, util

"""Default implementations of per-dialect sqlalchemy.engine classes.

These are semi-private implementation classes which are only of importance
to database dialect authors; dialects will usually use the classes here
as the base class for their own corresponding classes.

"""
AUTOCOMMIT_REGEXP = re.compile(r"\s*(?:UPDATE|INSERT|CREATE|DELETE|DROP|ALTER)", re.I | re.UNICODE)
SERVER_SIDE_CURSOR_RE = re.compile(r"\s*SELECT", re.I | re.UNICODE)
class DefaultDialect(interfaces.Dialect):
    """Default implementation of Dialect"""
    statement_compiler = ...
    ddl_compiler = ...
    type_compiler = ...
    preparer = ...
    supports_alter = ...
    supports_comments = ...
    inline_comments = ...
    default_sequence_base = ...
    execute_sequence_format = ...
    supports_views = ...
    supports_sequences = ...
    sequences_optional = ...
    preexecute_autoincrement_sequences = ...
    postfetch_lastrowid = ...
    implicit_returning = ...
    supports_right_nested_joins = ...
    cte_follows_insert = ...
    supports_native_enum = ...
    supports_native_boolean = ...
    non_native_boolean_check_constraint = ...
    supports_simple_order_by_label = ...
    tuple_in_values = ...
    engine_config_types = ...
    supports_native_decimal = ...
    if util.py3k:
        supports_unicode_statements = ...
        supports_unicode_binds = ...
        returns_unicode_strings = ...
        description_encoding = ...
    else:
        supports_unicode_statements = ...
        supports_unicode_binds = ...
        returns_unicode_strings = ...
        description_encoding = ...
    name = ...
    max_identifier_length = ...
    _user_defined_max_identifier_length = ...
    max_index_name_length = ...
    supports_sane_rowcount = ...
    supports_sane_multi_rowcount = ...
    colspecs = ...
    default_paramstyle = ...
    supports_default_values = ...
    supports_empty_insert = ...
    supports_multivalues_insert = ...
    supports_is_distinct_from = ...
    supports_server_side_cursors = ...
    supports_for_update_of = ...
    server_version_info = ...
    construct_arguments = ...
    requires_name_normalize = ...
    reflection_options = ...
    dbapi_exception_translation_map = ...
    @util.deprecated_params(convert_unicode=("1.3", "The :paramref:`_sa.create_engine.convert_unicode` parameter " "and corresponding dialect-level parameters are deprecated, " "and will be removed in a future release.  Modern DBAPIs support " "Python Unicode natively and this parameter is unnecessary."))
    def __init__(self, convert_unicode=..., encoding=..., paramstyle=..., dbapi=..., implicit_returning=..., supports_right_nested_joins=..., case_sensitive=..., supports_native_boolean=..., empty_in_strategy=..., max_identifier_length=..., label_length=..., **kwargs) -> None:
        ...
    
    @property
    def dialect_description(self):
        ...
    
    @property
    def supports_sane_rowcount_returning(self):
        """True if this dialect supports sane rowcount even if RETURNING is
        in use.

        For dialects that don't support RETURNING, this is synonymous with
        ``supports_sane_rowcount``.

        """
        ...
    
    @classmethod
    def get_pool_class(cls, url):
        ...
    
    @classmethod
    def load_provisioning(cls):
        ...
    
    def initialize(self, connection):
        ...
    
    def on_connect(self):
        ...
    
    def type_descriptor(self, typeobj):
        """Provide a database-specific :class:`.TypeEngine` object, given
        the generic object which comes from the types module.

        This method looks for a dictionary called
        ``colspecs`` as a class or instance-level variable,
        and passes on to :func:`_types.adapt_type`.

        """
        ...
    
    def reflecttable(self, connection, table, include_columns, exclude_columns, resolve_fks, **opts):
        ...
    
    def get_pk_constraint(self, conn, table_name, schema=..., **kw):
        """Compatibility method, adapts the result of get_primary_keys()
        for those dialects which don't implement get_pk_constraint().

        """
        ...
    
    def validate_identifier(self, ident):
        ...
    
    def connect(self, *cargs, **cparams):
        ...
    
    def create_connect_args(self, url):
        ...
    
    def set_engine_execution_options(self, engine, opts):
        ...
    
    def set_connection_execution_options(self, connection, opts):
        ...
    
    def do_begin(self, dbapi_connection):
        ...
    
    def do_rollback(self, dbapi_connection):
        ...
    
    def do_commit(self, dbapi_connection):
        ...
    
    def do_close(self, dbapi_connection):
        ...
    
    def do_ping(self, dbapi_connection):
        ...
    
    def create_xid(self):
        """Create a random two-phase transaction ID.

        This id will be passed to do_begin_twophase(), do_rollback_twophase(),
        do_commit_twophase().  Its format is unspecified.
        """
        ...
    
    def do_savepoint(self, connection, name):
        ...
    
    def do_rollback_to_savepoint(self, connection, name):
        ...
    
    def do_release_savepoint(self, connection, name):
        ...
    
    def do_executemany(self, cursor, statement, parameters, context=...):
        ...
    
    def do_execute(self, cursor, statement, parameters, context=...):
        ...
    
    def do_execute_no_params(self, cursor, statement, context=...):
        ...
    
    def is_disconnect(self, e, connection, cursor):
        ...
    
    def reset_isolation_level(self, dbapi_conn):
        ...
    
    def normalize_name(self, name):
        ...
    
    def denormalize_name(self, name):
        ...
    


class _RendersLiteral(object):
    def literal_processor(self, dialect):
        ...
    


class _StrDateTime(_RendersLiteral, sqltypes.DateTime):
    ...


class _StrDate(_RendersLiteral, sqltypes.Date):
    ...


class _StrTime(_RendersLiteral, sqltypes.Time):
    ...


class StrCompileDialect(DefaultDialect):
    statement_compiler = ...
    ddl_compiler = ...
    type_compiler = ...
    preparer = ...
    supports_sequences = ...
    sequences_optional = ...
    preexecute_autoincrement_sequences = ...
    implicit_returning = ...
    supports_native_boolean = ...
    supports_simple_order_by_label = ...
    colspecs = ...


class DefaultExecutionContext(interfaces.ExecutionContext):
    isinsert = ...
    isupdate = ...
    isdelete = ...
    is_crud = ...
    is_text = ...
    isddl = ...
    executemany = ...
    compiled = ...
    statement = ...
    result_column_struct = ...
    returned_defaults = ...
    _is_implicit_returning = ...
    _is_explicit_returning = ...
    _translate_colname = ...
    _expanded_parameters = ...
    @util.memoized_property
    def engine(self):
        ...
    
    @util.memoized_property
    def postfetch_cols(self):
        ...
    
    @util.memoized_property
    def prefetch_cols(self):
        ...
    
    @util.memoized_property
    def returning_cols(self):
        ...
    
    @util.memoized_property
    def no_parameters(self):
        ...
    
    @util.memoized_property
    def should_autocommit(self):
        ...
    
    @property
    def connection(self):
        ...
    
    def should_autocommit_text(self, statement):
        ...
    
    def create_cursor(self):
        ...
    
    def create_server_side_cursor(self):
        ...
    
    def pre_exec(self):
        ...
    
    def post_exec(self):
        ...
    
    def get_result_processor(self, type_, colname, coltype):
        """Return a 'result processor' for a given type as present in
        cursor.description.

        This has a default implementation that dialects can override
        for context-sensitive result type handling.

        """
        ...
    
    def get_lastrowid(self):
        """return self.cursor.lastrowid, or equivalent, after an INSERT.

        This may involve calling special cursor functions,
        issuing a new SELECT on the cursor (or a new one),
        or returning a stored value that was
        calculated within post_exec().

        This function will only be called for dialects
        which support "implicit" primary key generation,
        keep preexecute_autoincrement_sequences set to False,
        and when no explicit id value was bound to the
        statement.

        The function is called once, directly after
        post_exec() and before the transaction is committed
        or ResultProxy is generated.   If the post_exec()
        method assigns a value to `self._lastrowid`, the
        value is used in place of calling get_lastrowid().

        Note that this method is *not* equivalent to the
        ``lastrowid`` method on ``ResultProxy``, which is a
        direct proxy to the DBAPI ``lastrowid`` accessor
        in all cases.

        """
        ...
    
    def handle_dbapi_exception(self, e):
        ...
    
    def get_result_proxy(self):
        ...
    
    @property
    def rowcount(self):
        ...
    
    def supports_sane_rowcount(self):
        ...
    
    def supports_sane_multi_rowcount(self):
        ...
    
    def lastrow_has_defaults(self):
        ...
    
    def set_input_sizes(self, translate=..., include_types=..., exclude_types=...):
        """Given a cursor and ClauseParameters, call the appropriate
        style of ``setinputsizes()`` on the cursor, using DB-API types
        from the bind parameter's ``TypeEngine`` objects.

        This method only called by those dialects which require it,
        currently cx_oracle.

        """
        ...
    
    current_parameters = ...
    def get_current_parameters(self, isolate_multiinsert_groups=...):
        """Return a dictionary of parameters applied to the current row.

        This method can only be used in the context of a user-defined default
        generation function, e.g. as described at
        :ref:`context_default_functions`. When invoked, a dictionary is
        returned which includes entries for each column/value pair that is part
        of the INSERT or UPDATE statement. The keys of the dictionary will be
        the key value of each :class:`_schema.Column`,
        which is usually synonymous
        with the name.

        :param isolate_multiinsert_groups=True: indicates that multi-valued
         INSERT constructs created using :meth:`_expression.Insert.values`
         should be
         handled by returning only the subset of parameters that are local
         to the current column default invocation.   When ``False``, the
         raw parameters of the statement are returned including the
         naming convention used in the case of multi-valued INSERT.

        .. versionadded:: 1.2  added
           :meth:`.DefaultExecutionContext.get_current_parameters`
           which provides more functionality over the existing
           :attr:`.DefaultExecutionContext.current_parameters`
           attribute.

        .. seealso::

            :attr:`.DefaultExecutionContext.current_parameters`

            :ref:`context_default_functions`

        """
        ...
    
    def get_insert_default(self, column):
        ...
    
    def get_update_default(self, column):
        ...
    


