"""
This type stub file was generated by pyright.
"""

import re
from sqlalchemy.ext.declarative import DeclarativeMeta

def should_set_tablename(cls):
    """Determine whether ``__tablename__`` should be automatically generated
    for a model.

    * If no class in the MRO sets a name, one should be generated.
    * If a declared attr is found, it should be used instead.
    * If a name is found, it should be used if the class is a mixin, otherwise
      one should be generated.
    * Abstract models should not have one generated.

    Later, :meth:`._BoundDeclarativeMeta.__table_cls__` will determine if the
    model looks like single or joined-table inheritance. If no primary key is
    found, the name will be unset.
    """
    ...

camelcase_re = re.compile(r'([A-Z]+)(?=[a-z0-9])')
def camel_to_snake_case(name):
    ...

class NameMetaMixin(type):
    def __init__(cls, name, bases, d) -> None:
        ...
    
    def __table_cls__(cls, *args, **kwargs):
        """This is called by SQLAlchemy during mapper setup. It determines the
        final table object that the model will use.

        If no primary key is found, that indicates single-table inheritance,
        so no table will be created and ``__tablename__`` will be unset.
        """
        ...
    


class BindMetaMixin(type):
    def __init__(cls, name, bases, d) -> None:
        ...
    


class DefaultMeta(NameMetaMixin, BindMetaMixin, DeclarativeMeta):
    ...


class Model(object):
    """Base class for SQLAlchemy declarative base model.

    To define models, subclass :attr:`db.Model <SQLAlchemy.Model>`, not this
    class. To customize ``db.Model``, subclass this and pass it as
    ``model_class`` to :class:`SQLAlchemy`.
    """
    query_class = ...
    query = ...
    def __repr__(self):
        ...
    


