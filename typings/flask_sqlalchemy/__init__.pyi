"""
This type stub file was generated by pyright.
"""

import functools
import os
import sys
import time
from typing import Any, Type
import warnings
from __future__ import absolute_import
from math import ceil
from operator import itemgetter
from threading import Lock
from flask import _app_ctx_stack, abort, current_app, request
from flask.signals import Namespace
from sqlalchemy import event, inspect, orm, MetaData
import sqlalchemy
from sqlalchemy.ext.declarative.api import DeclarativeMeta, declarative_base
from sqlalchemy.orm.scoping import scoped_session
from sqlalchemy.ext.declarative import declarative_base
import sqlalchemy as sa
from sqlalchemy.engine.url import make_url
from sqlalchemy.ext.declarative import DeclarativeMeta
from sqlalchemy.orm.exc import UnmappedClassError
from sqlalchemy.orm.session import Session as SessionBase
from sqlalchemy.sql.schema import MetaData
from ._compat import itervalues, string_types, xrange
from .model import DefaultMeta, Model
from .model import Model as SAModel
from . import utils

__version__ = "2.4.4"
if sys.platform == "win32":
    ...
else:
    _timer = time.time
_signals = Namespace()
models_committed = _signals.signal("models-committed")
before_models_committed = _signals.signal("before-models-committed")


class _DebugQueryTuple(tuple):
    statement = ...
    parameters = ...
    start_time = ...
    end_time = ...
    context = ...

    @property
    def duration(self):
        ...

    def __repr__(self):
        ...


class SignallingSession(SessionBase):
    """The signalling session is the default session that Flask-SQLAlchemy
    uses.  It extends the default session system with bind selection and
    modification tracking.

    If you want to use a different session you can override the
    :meth:`SQLAlchemy.create_session` function.

    .. versionadded:: 2.0

    .. versionadded:: 2.1
        The `binds` option was added, which allows a session to be joined
        to an external transaction.
    """

    def __init__(self, db, autocommit=..., autoflush=..., **options) -> None:
        ...

    def get_bind(self, mapper=..., clause=...):
        """Return the engine or connection for a given model or
        table, using the ``__bind_key__`` if it is set.
        """
        ...


class _SessionSignalEvents(object):
    @classmethod
    def register(cls, session):
        ...

    @classmethod
    def unregister(cls, session):
        ...

    @staticmethod
    def record_ops(session, flush_context=..., instances=...):
        ...

    @staticmethod
    def before_commit(session):
        ...

    @staticmethod
    def after_commit(session):
        ...

    @staticmethod
    def after_rollback(session):
        ...


class _EngineDebuggingSignalEvents(object):
    """Sets up handlers for two events that let us track the execution time of
    queries."""

    def __init__(self, engine, import_name) -> None:
        ...

    def register(self):
        ...

    def before_cursor_execute(
        self, conn, cursor, statement, parameters, context, executemany
    ):
        ...

    def after_cursor_execute(
        self, conn, cursor, statement, parameters, context, executemany
    ):
        ...


def get_debug_queries():
    """In debug mode Flask-SQLAlchemy will log all the SQL queries sent
    to the database.  This information is available until the end of request
    which makes it possible to easily ensure that the SQL generated is the
    one expected on errors or in unittesting.  If you don't want to enable
    the DEBUG mode for your unittests you can also enable the query
    recording by setting the ``'SQLALCHEMY_RECORD_QUERIES'`` config variable
    to `True`.  This is automatically enabled if Flask is in testing mode.

    The value returned will be a list of named tuples with the following
    attributes:

    `statement`
        The SQL statement issued

    `parameters`
        The parameters for the SQL statement

    `start_time` / `end_time`
        Time the query started / the results arrived.  Please keep in mind
        that the timer function used depends on your platform. These
        values are only useful for sorting or comparing.  They do not
        necessarily represent an absolute timestamp.

    `duration`
        Time the query took in seconds

    `context`
        A string giving a rough estimation of where in your application
        query was issued.  The exact format is undefined so don't try
        to reconstruct filename or function name.
    """
    ...


class Pagination(object):
    """Internal helper class returned by :meth:`BaseQuery.paginate`.  You
    can also construct it from any other SQLAlchemy query object if you are
    working with other libraries.  Additionally it is possible to pass `None`
    as query object in which case the :meth:`prev` and :meth:`next` will
    no longer work.
    """

    def __init__(self, query, page, per_page, total, items) -> None:
        ...

    @property
    def pages(self):
        """The total number of pages"""
        ...

    def prev(self, error_out=...):
        """Returns a :class:`Pagination` object for the previous page."""
        ...

    @property
    def prev_num(self):
        """Number of the previous page."""
        ...

    @property
    def has_prev(self):
        """True if a previous page exists"""
        ...

    def next(self, error_out=...):
        """Returns a :class:`Pagination` object for the next page."""
        ...

    @property
    def has_next(self):
        """True if a next page exists."""
        ...

    @property
    def next_num(self):
        """Number of the next page"""
        ...

    def iter_pages(
        self, left_edge=..., left_current=..., right_current=..., right_edge=...
    ):
        """Iterates over the page numbers in the pagination.  The four
        parameters control the thresholds how many numbers should be produced
        from the sides.  Skipped page numbers are represented as `None`.
        This is how you could render such a pagination in the templates:

        .. sourcecode:: html+jinja

            {% macro render_pagination(pagination, endpoint) %}
              <div class=pagination>
              {%- for page in pagination.iter_pages() %}
                {% if page %}
                  {% if page != pagination.page %}
                    <a href="{{ url_for(endpoint, page=page) }}">{{ page }}</a>
                  {% else %}
                    <strong>{{ page }}</strong>
                  {% endif %}
                {% else %}
                  <span class=ellipsis>â€¦</span>
                {% endif %}
              {%- endfor %}
              </div>
            {% endmacro %}
        """
        ...


class BaseQuery(orm.Query):
    """SQLAlchemy :class:`~sqlalchemy.orm.query.Query` subclass with convenience methods for querying in a web application.

    This is the default :attr:`~Model.query` object used for models, and exposed as :attr:`~SQLAlchemy.Query`.
    Override the query class for an individual model by subclassing this and setting :attr:`~Model.query_class`.
    """

    def get_or_404(self, ident, description=...):
        """Like :meth:`get` but aborts with 404 if not found instead of returning ``None``."""
        ...

    def first_or_404(self, description=...):
        """Like :meth:`first` but aborts with 404 if not found instead of returning ``None``."""
        ...

    def paginate(self, page=..., per_page=..., error_out=..., max_per_page=...):
        """Returns ``per_page`` items from page ``page``.

        If ``page`` or ``per_page`` are ``None``, they will be retrieved from
        the request query. If ``max_per_page`` is specified, ``per_page`` will
        be limited to that value. If there is no request or they aren't in the
        query, they default to 1 and 20 respectively.

        When ``error_out`` is ``True`` (default), the following rules will
        cause a 404 response:

        * No items are found and ``page`` is not 1.
        * ``page`` is less than 1, or ``per_page`` is negative.
        * ``page`` or ``per_page`` are not ints.

        When ``error_out`` is ``False``, ``page`` and ``per_page`` default to
        1 and 20 respectively.

        Returns a :class:`Pagination` object.
        """
        ...


class _QueryProperty(object):
    def __init__(self, sa) -> None:
        ...

    def __get__(self, obj, type):
        ...


class _EngineConnector(object):
    def __init__(self, sa, app, bind=...) -> None:
        ...

    def get_uri(self):
        ...

    def get_engine(self):
        ...

    def get_options(self, sa_url, echo):
        ...


def get_state(app):
    """Gets the state for the application"""
    ...


class _SQLAlchemyState(object):
    """Remembers configuration for the (db, app) tuple."""

    def __init__(self, db) -> None:
        ...


class SQLAlchemy(object):
    """This class is used to control the SQLAlchemy integration to one
    or more Flask applications.  Depending on how you initialize the
    object it is usable right away or will attach as needed to a
    Flask application.

    There are two usage modes which work very similarly.  One is binding
    the instance to a very specific Flask application::

        app = Flask(__name__)
        db = SQLAlchemy(app)

    The second possibility is to create the object once and configure the
    application later to support it::

        db = SQLAlchemy()

        def create_app():
            app = Flask(__name__)
            db.init_app(app)
            return app

    The difference between the two is that in the first case methods like
    :meth:`create_all` and :meth:`drop_all` will work all the time but in
    the second case a :meth:`flask.Flask.app_context` has to exist.

    By default Flask-SQLAlchemy will apply some backend-specific settings
    to improve your experience with them.

    As of SQLAlchemy 0.6 SQLAlchemy
    will probe the library for native unicode support.  If it detects
    unicode it will let the library handle that, otherwise do that itself.
    Sometimes this detection can fail in which case you might want to set
    ``use_native_unicode`` (or the ``SQLALCHEMY_NATIVE_UNICODE`` configuration
    key) to ``False``.  Note that the configuration key overrides the
    value you pass to the constructor.  Direct support for ``use_native_unicode``
    and SQLALCHEMY_NATIVE_UNICODE are deprecated as of v2.4 and will be removed
    in v3.0.  ``engine_options`` and ``SQLALCHEMY_ENGINE_OPTIONS`` may be used
    instead.

    This class also provides access to all the SQLAlchemy functions and classes
    from the :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` modules.  So you can
    declare models like this::

        class User(db.Model):
            username = db.Column(db.String(80), unique=True)
            pw_hash = db.Column(db.String(80))

    You can still use :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` directly, but
    note that Flask-SQLAlchemy customizations are available only through an
    instance of this :class:`SQLAlchemy` class.  Query classes default to
    :class:`BaseQuery` for `db.Query`, `db.Model.query_class`, and the default
    query_class for `db.relationship` and `db.backref`.  If you use these
    interfaces through :mod:`sqlalchemy` and :mod:`sqlalchemy.orm` directly,
    the default query class will be that of :mod:`sqlalchemy`.

    .. admonition:: Check types carefully

       Don't perform type or `isinstance` checks against `db.Table`, which
       emulates `Table` behavior but is not a class. `db.Table` exposes the
       `Table` interface, but is a function which allows omission of metadata.

    The ``session_options`` parameter, if provided, is a dict of parameters
    to be passed to the session constructor.  See :class:`~sqlalchemy.orm.session.Session`
    for the standard options.

    The ``engine_options`` parameter, if provided, is a dict of parameters
    to be passed to create engine.  See :func:`~sqlalchemy.create_engine`
    for the standard options.  The values given here will be merged with and
    override anything set in the ``'SQLALCHEMY_ENGINE_OPTIONS'`` config
    variable or othewise set by this library.

    .. versionadded:: 0.10
       The `session_options` parameter was added.

    .. versionadded:: 0.16
       `scopefunc` is now accepted on `session_options`. It allows specifying
        a custom function which will define the SQLAlchemy session's scoping.

    .. versionadded:: 2.1
       The `metadata` parameter was added. This allows for setting custom
       naming conventions among other, non-trivial things.

       The `query_class` parameter was added, to allow customisation
       of the query class, in place of the default of :class:`BaseQuery`.

       The `model_class` parameter was added, which allows a custom model
       class to be used in place of :class:`Model`.

    .. versionchanged:: 2.1
       Utilise the same query class across `session`, `Model.query` and `Query`.

    .. versionadded:: 2.4
       The `engine_options` parameter was added.

    .. versionchanged:: 2.4
       The `use_native_unicode` parameter was deprecated.

    .. versionchanged:: 2.4.3
        ``COMMIT_ON_TEARDOWN`` is deprecated and will be removed in
        version 3.1. Call ``db.session.commit()`` directly instead.
    """

    Model: Type[SAModel] = ...
    Query: BaseQuery = ...

    event: Any = ...

    # the following attributes are directly remapped from sqlalchemy...
    inspect: sa.inspect = ...
    CheckConstraint: sa.CheckConstraint = ...
    Column: sa.Column = ...
    ColumnDefault: sa.ColumnDefault = ...
    Computed: sa.Computed = ...
    Constraint: sa.Constraint = ...
    DDL: sa.DDL = ...
    DefaultClause: sa.DefaultClause = ...
    FetchedValue: sa.FetchedValue = ...
    ForeignKey: sa.ForeignKey = ...
    ForeignKeyConstraint: sa.ForeignKeyConstraint = ...
    IdentityOptions: sa.IdentityOptions = ...
    Index: sa.Index = ...
    MetaData: sa.MetaData = ...
    PassiveDefault: sa.PassiveDefault = ...
    PrimaryKeyConstraint: sa.PrimaryKeyConstraint = ...
    Sequence: sa.Sequence = ...
    Table: sa.Table = ...
    ThreadLocalMetaData: sa.ThreadLocalMetaData = ...
    UniqueConstraint: sa.UniqueConstraint = ...

    alias: sa.alias = ...
    all_: sa.all_ = ...
    and_: sa.and_ = ...
    any_: sa.any_ = ...
    asc: sa.asc = ...
    between: sa.between = ...
    bindparam: sa.bindparam = ...
    case: sa.case = ...
    cast: sa.cast = ...
    collate: sa.collate = ...
    column: sa.column = ...
    delete: sa.delete = ...
    desc: sa.desc = ...
    distinct: sa.distinct = ...
    except_: sa.except_ = ...
    except_all: sa.except_all = ...
    exists: sa.exists = ...
    extract: sa.extract = ...
    false: sa.false = ...
    func: sa.func = ...
    funcfilter: sa.funcfilter = ...
    insert: sa.insert = ...
    intersect: sa.intersect = ...
    intersect_all: sa.intersect_all = ...
    join: sa.join = ...
    lateral: sa.lateral = ...
    literal: sa.literal = ...
    literal_column: sa.literal_column = ...
    modifier: sa.modifier = ...
    not_: sa.not_ = ...
    null: sa.null = ...
    nullsfirst: sa.nullsfirst = ...
    nullslast: sa.nullslast = ...
    or_: sa.or_ = ...
    outerjoin: sa.outerjoin = ...
    outparam: sa.outparam = ...
    over: sa.over = ...
    select: sa.select = ...
    subquery: sa.subquery = ...
    table: sa.table = ...
    tablesample: sa.tablesample = ...
    text: sa.text = ...
    true: sa.true = ...
    tuple_: sa.tuple_ = ...
    type_coerce: sa.type_coerce = ...
    union: sa.union = ...
    union_all: sa.union_all = ...
    update: sa.update = ...
    within_group: sa.within_group = ...

    ARRAY: sa.ARRAY = ...
    BIGINT: sa.BIGINT = ...
    BigInteger: sa.BigInteger = ...
    BINARY: sa.BINARY = ...
    Binary: sa.Binary = ...
    BLOB: sa.BLOB = ...
    BOOLEAN: sa.BOOLEAN = ...
    Boolean: sa.Boolean = ...
    CHAR: sa.CHAR = ...
    CLOB: sa.CLOB = ...
    DATE: sa.DATE = ...
    Date: sa.Date = ...
    DATETIME: sa.DATETIME = ...
    DateTime: sa.DateTime = ...
    DECIMAL: sa.DECIMAL = ...
    Enum: sa.Enum = ...
    FLOAT: sa.FLOAT = ...
    Float: sa.Float = ...
    INT: sa.INT = ...
    INTEGER: sa.INTEGER = ...
    Integer: sa.Integer = ...
    Interval: sa.Interval = ...
    JSON: sa.JSON = ...
    LargeBinary: sa.LargeBinary = ...
    NCHAR: sa.NCHAR = ...
    NUMERIC: sa.NUMERIC = ...
    Numeric: sa.Numeric = ...
    NVARCHAR: sa.NVARCHAR = ...
    PickleType: sa.PickleType = ...
    REAL: sa.REAL = ...
    SMALLINT: sa.SMALLINT = ...
    SmallInteger: sa.SmallInteger = ...
    String: sa.String = ...
    TEXT: sa.TEXT = ...
    Text: sa.Text = ...
    TIME: sa.TIME = ...
    Time: sa.Time = ...
    TIMESTAMP: sa.TIMESTAMP = ...
    TypeDecorator: sa.TypeDecorator = ...
    Unicode: sa.Unicode = ...
    UnicodeText: sa.UnicodeText = ...
    VARBINARY: sa.VARBINARY = ...
    VARCHAR: sa.VARCHAR = ...

    # The following attributes are directly mapped from orm
    AliasOption: orm.AliasOption = ...
    AttributeExtension: orm.AttributeExtension = ...
    Bundle: orm.Bundle = ...
    ColumnProperty: orm.ColumnProperty = ...
    ComparableProperty: orm.ComparableProperty = ...
    CompositeProperty: orm.CompositeProperty = ...
    EXT_CONTINUE: orm.EXT_CONTINUE = ...
    EXT_SKIP: orm.EXT_SKIP = ...
    EXT_STOP: orm.EXT_STOP = ...
    Load: orm.Load = ...
    Mapper: orm.Mapper = ...
    MapperExtension: orm.MapperExtension = ...
    PropComparator: orm.PropComparator = ...
    RelationshipProperty: orm.RelationshipProperty = ...
    Session: orm.Session = ...
    SessionExtension: orm.SessionExtension = ...
    SynonymProperty: orm.SynonymProperty = ...
    aliased: orm.aliased = ...
    backref: orm.backref = ...
    class_mapper: orm.class_mapper = ...
    clear_mappers: orm.clear_mappers = ...
    close_all_sessions: orm.close_all_sessions = ...
    column_property: orm.column_property = ...
    comparable_property: orm.comparable_property = ...
    compile_mappers: orm.compile_mappers = ...
    composite: orm.composite = ...
    configure_mappers: orm.configure_mappers = ...
    contains_alias: orm.contains_alias = ...
    contains_eager: orm.contains_eager = ...
    create_session: orm.create_session = ...
    defaultload: orm.defaultload = ...
    defer: orm.defer = ...
    deferred: orm.deferred = ...
    dynamic_loader: orm.dynamic_loader = ...
    eagerload: orm.eagerload = ...
    eagerload_all: orm.eagerload_all = ...
    foreign: orm.foreign = ...
    immediateload: orm.immediateload = ...
    join: orm.join = ...
    joinedload: orm.joinedload = ...
    joinedload_all: orm.joinedload_all = ...
    lazyload: orm.lazyload = ...
    lazyload_all: orm.lazyload_all = ...
    load_only: orm.load_only = ...
    make_transient: orm.make_transient = ...
    make_transient_to_detached: orm.make_transient_to_detached = ...
    mapper: orm.mapper = ...
    noload: orm.noload = ...
    object_mapper: orm.object_mapper = ...
    object_session: orm.object_session = ...
    outerjoin: orm.outerjoin = ...
    polymorphic_union: orm.polymorphic_union = ...
    public_factory: orm.public_factory = ...
    query_expression: orm.query_expression = ...
    raiseload: orm.raiseload = ...
    reconstructor: orm.reconstructor = ...
    relation: orm.relation = ...
    relationship: orm.relationship = ...
    remote: orm.remote = ...
    scoped_session: orm.scoped_session = ...
    selectin_polymorphic: orm.selectin_polymorphic = ...
    selectinload: orm.selectinload = ...
    selectinload_all: orm.selectinload_all = ...
    sessionmaker: orm.sessionmaker = ...
    subqueryload: orm.subqueryload = ...
    subqueryload_all: orm.subqueryload_all = ...
    synonym: orm.synonym = ...
    undefer: orm.undefer = ...
    undefer_group: orm.undefer_group = ...
    validates: orm.validates = ...
    was_deleted: orm.was_deleted = ...
    with_expression: orm.with_expression = ...
    with_parent: orm.with_parent = ...
    with_polymorphic: orm.with_polymorphic = ...

    # The code injecting all extra attributes into this class
    # for module in sqlalchemy, sqlalchemy.orm:
    #     for key in module.__all__:
    #         if not hasattr(obj, key):
    #             setattr(obj, key, getattr(module, key))
    # # Note: obj.Table does not attempt to be a SQLAlchemy Table class.
    # obj.Table = _make_table(obj)
    # obj.relationship = _wrap_with_default_query_class(obj.relationship, cls)
    # obj.relation = _wrap_with_default_query_class(obj.relation, cls)
    # obj.dynamic_loader = _wrap_with_default_query_class(obj.dynamic_loader, cls)
    # obj.event = event

    def __init__(
        self,
        app=...,
        use_native_unicode: bool = ...,
        session_options=...,
        metadata=...,
        query_class: BaseQuery = ...,
        model_class: SAModel = ...,
        engine_options=...,
    ) -> None:
        ...

    @property
    def metadata(self):
        """The metadata associated with ``db.Model``."""
        ...

    def create_scoped_session(self, options=...) -> scoped_session:
        """Create a :class:`~sqlalchemy.orm.scoping.scoped_session`
        on the factory from :meth:`create_session`.

        An extra key ``'scopefunc'`` can be set on the ``options`` dict to
        specify a custom scope function.  If it's not provided, Flask's app
        context stack identity is used. This will ensure that sessions are
        created and removed with the request/response cycle, and should be fine
        in most cases.

        :param options: dict of keyword arguments passed to session class  in
            ``create_session``
        """
        ...

    def create_session(self, options) -> orm.session.sessionmaker:
        """Create the session factory used by :meth:`create_scoped_session`.

        The factory **must** return an object that SQLAlchemy recognizes as a session,
        or registering session events may raise an exception.

        Valid factories include a :class:`~sqlalchemy.orm.session.Session`
        class or a :class:`~sqlalchemy.orm.session.sessionmaker`.

        The default implementation creates a ``sessionmaker`` for :class:`SignallingSession`.

        :param options: dict of keyword arguments passed to session class
        """
        ...

    def make_declarative_base(self, model, metadata: MetaData = ...) -> DeclarativeMeta:
        """Creates the declarative base that all models will inherit from.

        :param model: base model class (or a tuple of base classes) to pass
            to :func:`~sqlalchemy.ext.declarative.declarative_base`. Or a class
            returned from ``declarative_base``, in which case a new base class
            is not created.
        :param metadata: :class:`~sqlalchemy.MetaData` instance to use, or
            none to use SQLAlchemy's default.

        .. versionchanged 2.3.0::
            ``model`` can be an existing declarative base in order to support
            complex customization such as changing the metaclass.
        """
        ...

    def init_app(self, app):
        """This callback can be used to initialize an application for the
        use with this database setup.  Never use a database in the context
        of an application not initialized that way or connections will
        leak.
        """
        ...

    def apply_pool_defaults(self, app, options):
        ...

    def apply_driver_hacks(self, app, sa_url, options):
        """This method is called before engine creation and used to inject
        driver specific hacks into the options.  The `options` parameter is
        a dictionary of keyword arguments that will then be used to call
        the :func:`sqlalchemy.create_engine` function.

        The default implementation provides some saner defaults for things
        like pool sizes for MySQL and sqlite.  Also it injects the setting of
        `SQLALCHEMY_NATIVE_UNICODE`.
        """
        ...

    @property
    def engine(self):
        """Gives access to the engine.  If the database configuration is bound
        to a specific application (initialized with an application) this will
        always return a database connection.  If however the current application
        is used this might raise a :exc:`RuntimeError` if no application is
        active at the moment.
        """
        ...

    def make_connector(self, app=..., bind=...):
        """Creates the connector for a given state and bind."""
        ...

    def get_engine(self, app=..., bind=...):
        """Returns a specific engine."""
        ...

    def create_engine(self, sa_url, engine_opts):
        """
        Override this method to have final say over how the SQLAlchemy engine
        is created.

        In most cases, you will want to use ``'SQLALCHEMY_ENGINE_OPTIONS'``
        config variable or set ``engine_options`` for :func:`SQLAlchemy`.
        """
        ...

    def get_app(self, reference_app=...):
        """Helper method that implements the logic to look up an
        application."""
        ...

    def get_tables_for_bind(self, bind=...):
        """Returns a list of all tables relevant for a bind."""
        ...

    def get_binds(self, app=...):
        """Returns a dictionary with a table->engine mapping.

        This is suitable for use of sessionmaker(binds=db.get_binds(app)).
        """
        ...

    def create_all(self, bind=..., app=...):
        """Creates all tables.

        .. versionchanged:: 0.12
           Parameters were added
        """
        ...

    def drop_all(self, bind=..., app=...):
        """Drops all tables.

        .. versionchanged:: 0.12
           Parameters were added
        """
        ...

    def reflect(self, bind=..., app=...):
        """Reflects tables from the database.

        .. versionchanged:: 0.12
           Parameters were added
        """
        ...

    def __repr__(self):
        ...


class _BoundDeclarativeMeta(DefaultMeta):
    def __init__(cls, name, bases, d) -> None:
        ...


class FSADeprecationWarning(DeprecationWarning):
    ...
